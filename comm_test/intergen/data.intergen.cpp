
//@file  interface dispatcher generated by intergen v9
//See LICENSE file for copyright and license information

#include "ifc/component_ifc.h"
#include "data.hpp"

#include <comm/ref.h>
#include <comm/global.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>

static_assert(intergen_interface::VERSION == 9, "interface must be rebuilt with a different intergen version");

using namespace coid;

////////////////////////////////////////////////////////////////////////////////
// data interface component_ifc of class component


///
class component_ifc_data_dispatcher : public component_ifc
{
    friend class component_ifc;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    inline static const meta::arg creator_0args[] = {
       { "return", "iref<component>", "component", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, true, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg set_a_1args[] = {
       { "b", "int", "int", "", "", "", "", &meta::stream_op<int>::fn, meta::arg::ifc_type::none, false, false, false, false, false, false, true, false, false, false, false, "" },
    };
    inline static const meta::arg set_b_2args[] = {
       { "a", "const coid::token&", "coid::token", "", "", "", "", &meta::stream_op<coid::token>::fn, meta::arg::ifc_type::none, false, false, true, false, false, false, true, false, false, false, false, "" },
       { "b", "int*", "int", "", "", "", "", nullptr, meta::arg::ifc_type::none, false, true, false, false, false, false, false, true, false, false, false, "" },
    };
    inline static const meta::method creators[] = {
        { "creator", bstatic|bnoevbody, 0, 0, 0, nullptr },
    };
    inline static const meta::method methods[] = {
        { "set_a", meta::method::flg(0), 1, 1, 0, set_a_1args },
        { "set_b", bnoevbody, 2, 1, 1, set_b_2args },
    };
    inline static const meta::method* events = nullptr;
    inline static const meta::class_interface ifc_meta = {
        "component_ifc", // interface name
        "component_ifc.h", // header file
        "iref<component>", // storage
        "", // base class name
        873153888, //version
        1, 2, 0, // num. creators/methods/events
        creators, methods, events,
        -1, 0, -1, -1,
        bdataifc,
        R"##()##",
    };

private:

    inline static ifn_t _fn_table[] = {
        reinterpret_cast<ifn_t>((void(intergen_data_interface::*)(int))(&::component::set_a)),
        reinterpret_cast<ifn_t>((void(intergen_data_interface::*)(const coid::token&,int*))(&::component::set_b)),
        nullptr
    };
    inline static icr_t _cr_table[] = {
        reinterpret_cast<icr_t>(&::component::creator),
        nullptr
    };

protected:

    COIDNEWDELETE(component_ifc_data_dispatcher);

    component_ifc_data_dispatcher() = default;
    ~component_ifc_data_dispatcher() = default;

    static coref<component_ifc> _host_connector(::component* host)
    {
        get_data_ifc_descriptor();
        return coref<component_ifc>::from_host(host);
    }

public:

    static void register_interfaces(bool on)
    {
        coid::ifcman::set_type_ifc<component_ifc>(HASHID, _cr_table, _fn_table, &ifc_meta);

        interface_register::register_interface_creator("component_ifc@dcconnect", on ? (void*)&_host_connector : nullptr, &ifc_meta);
    }
};


//auto-register the available interface creators
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) component_ifc_autoregger = new ifc_autoregger(&component_ifc_data_dispatcher::register_interfaces);

void* force_register_component_ifc() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&component_ifc_data_dispatcher::register_interfaces);
    return autoregger.get();
}



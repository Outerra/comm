
//@file $name$ interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

$-[class]$$[iface]$
#include "$relpath$"
$-[/iface]$$[iface_data]$
#include "$relpath$"
$-[/iface_data]$$[/class]$
#include "$hdr$"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>

static_assert(intergen_interface::VERSION == $version$, "interface must be rebuilt with a different intergen version");
$-[pastedefers]$

$@value$
$-[/pastedefers]$

using namespace coid;

$-[class]$
$-(if !iface.empty)$
static_assert(std::is_base_of<policy_intrusive_base, ::$nsx$$class$>::value, "class '$nsx$$class$' must be derived from policy_intrusive_base");

$-(/if)$
$-[iface]$
////////////////////////////////////////////////////////////////////////////////
// interface $ns suffix="::"$$name$ of class $..nsx$$..class$
$[ns]$
namespace $@value$ {
$-[/ns]$

///
class $name$_dispatcher : public $name$
{
    friend class $name$;
    using enum meta::method::flg;
    using enum meta::class_interface::flg;

    $-[method !args.empty]$
    inline static const meta::arg $basename$_$@index$args[] = {$[args]$
       { "$name$", "$type$", "$basetype$", "$barens$", "$baretype$", "$argsize$", "$fnargs$", "$memfnclass$", "$defval$", $(if | ?..internal ?nojs ?type="void" ?iref ?ptr)$nullptr$(elif)$&meta::stream_op<$basetype$>::fn$(/if)$, $specptr$, $ptr$, $ref$, $xref$, $iref$, $const$, $struct_type$, $inarg$, $outarg$, $volatile$, $nojs$, $fnarg$, "$doc\"$" },$[/args]$
    };$[/method]$
    inline static const meta::method$(if method ?static)$ creators[] = {$[method ?static]$
        { "$name$", $static set="bstatic|"$ $-ptr set="bptr|"$ $-iref set="biref|"$ $-ifccr set="bifccr|"$ $-const set="bconst|"$ $-operator set="boperator|"$ $-internal set="binternal|"$ $-capture set="bcapture|"$ $-implicit set="bimplicit|"$ $-destroy set="bdestroy|"$ $-noevbody set="bnoevbody|"$ $-pure set="bpure|"$ $-duplicate set="bduplicate|"$ $-inherit set="binherit|"$ $-(if !@revert="|")$meta::method::flg(0)$(/if)$, $args.@size$, $ninargs$, $noutargs$, $(if ?args.empty)$nullptr$(elif)$$basename$_$@index$args$(/if)$ },$[/method]$
    };$(elif)$* creators = nullptr;$(/if)$
    inline static const meta::method$(if method !static)$ methods[] = {$[method !static]$
        { "$name$", $static set="bstatic|"$ $-ptr set="bptr|"$ $-iref set="biref|"$ $-ifccr set="bifccr|"$ $-const set="bconst|"$ $-operator set="boperator|"$ $-internal set="binternal|"$ $-capture set="bcapture|"$ $-implicit set="bimplicit|"$ $-destroy set="bdestroy|"$ $-noevbody set="bnoevbody|"$ $-pure set="bpure|"$ $-duplicate set="bduplicate|"$ $-inherit set="binherit|"$ $-(if !@revert="|")$meta::method::flg(0)$(/if)$, $args.@size$, $ninargs$, $noutargs$, $(if ?args.empty)$nullptr$(elif)$$basename$_$@index$args$(/if)$ },$[/method]$
    };$(elif)$* methods = nullptr;$(/if)$
    $-[event !args.empty]$
    inline static const meta::arg $basename$_$@index$args[] = {$[args]$
       { "$name$", "$type$", "$basetype$", "$barens$", "$baretype$", "$argsize$", "$fnargs$", "$memfnclass$", "$defval$", $(if | ?..internal ?nojs ?type="void" ?iref ?ptr)$nullptr$(elif)$&meta::stream_op<$basetype$>::fn$(/if)$, $specptr$, $ptr$, $ref$, $xref$, $iref$, $const$, $struct_type$, $inarg$, $outarg$, $volatile$, $nojs$, $fnarg$, "$doc\"$" },$[/args]$
    };$[/event]$
    inline static const meta::method$(if event)$ events[] = {$[event]$
        { "$name$", $static set="bstatic|"$ $-ptr set="bptr|"$ $-iref set="biref|"$ $-ifccr set="bifccr|"$ $-const set="bconst|"$ $-operator set="boperator|"$ $-internal set="binternal|"$ $-capture set="bcapture|"$ $-implicit set="bimplicit|"$ $-destroy set="bdestroy|"$ $-noevbody set="bnoevbody|"$ $-pure set="bpure|"$ $-duplicate set="bduplicate|"$ $-inherit set="binherit|"$ $-(if !@revert="|")$meta::method::flg(0)$(/if)$, $args.@size$, $ninargs$, $noutargs$, $(if ?args.empty)$nullptr$(elif)$$basename$_$@index$args$(/if)$ },$[/event]$
    };$(elif)$* events = nullptr;$(/if)$
    inline static const meta::class_interface ifc_meta = {
        "$[ns]$$@value$::$[/ns]$$name$", // interface name
        "$hdrfile$", // header file
        "$storage$", // storage
        "$baseclassnss suffix="::"$$baseclass$", // base class name
        $hash$, //version
        $method.@size ?static$, $method.@size !static$, $event.@size$, // num. creators/methods/events
        creators, methods, events,
        $method.@first_index ?destroy$, $method.@first_index ?creator !args$, $method.@first_index ?operator ?const$, $method.@first_index ?operator !const$,
        $virtual set="bvirtual|"$ $-dataifc set="bdataifc|"$ $-(if !@revert="|")$meta::class_interface::flg(0)$(/if)$,
        R"##($comments rest="\n"$)##",
    };

private:

    inline static coid::binstring* _capture = 0;
    inline static uint16 _instid = 0xffffU;
    inline static ifn_t* _vtable1 = 0;
    inline static ifn_t* _vtable2 = 0;

    static ifn_t* get_vtable()
    {
$-(if !virtual)$
        if (_vtable1) return _vtable1;

        _vtable1 = new ifn_t[$method.@size !static$];
$-[method !static]$
        _vtable1[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$ $-(if ?fnarg)$$type$($memfnclass after="::"$*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$)$(if ?const)$const$(/if)$>(&::$classname$::$intname$));
$-[/method]-$

        return _vtable1;
$-(elif)$
        return 0;
$-(/if)$
    }

    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))

$-[method ?capture]$

    $return.type$ __capture__$(if ?operator)$operator$(elif)$$name$$index$$(/if)$($[args rest=", "]$$type$ $name$$[/args]$)$(if ?const)$ const$(/if)$
    {
        (*_capture) << uint16(_instid | $index$) $-[args ?inarg]$ << $name$$[/args]$;
        return VT_CALL2($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
    }
$-[/method]$

    static ifn_t* get_vtable_intercept()
    {
$-(if !virtual)$
        if (_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[$method.@size !static$];
$-[method !static]$
    $-(if ?capture ?operator)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if ?const)$const$(/if)$>(&__capture__operator));
    $-(elif ?capture)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if ?const)$const$(/if)$>(&__capture__$name$$index$));
    $-(elif)$
        _vtable2[$@order$] = vtable1[$@order$];
    $-(/if)$
$-[/method]-$

        return _vtable2;
$-(elif)$
        return 0;
$-(/if)$
    }

$-[event ?pure]$
    $return.type$ $name$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if ?fnarg)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if ?const)$ const$(/if)$ override { throw coid::exception("unreachable"); }
$-[/event]$

protected:

    COIDNEWDELETE($name$_dispatcher);

    $name$_dispatcher() {
    }

    virtual ~$name$_dispatcher() {
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        if (instid >= 0xffU)
            return false;

        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        switch(mid) {
        $-[method ?capture !noutargs]$
        case $index$: {
            $-[args ?inarg]$
            $-(if ?token)$
            coid::token $name$ = bin.string();
            $-(elif)$
            const $basetype$& $name$ = bin.fetch<$basetype$>();
            $-(/if)$
            $-[/args]$
            VT_CALL($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
            break;
        }
        $-[/method]$
        case UMAX32:
        default: throw coid::exception("unknown method id in $name$ capture dispatcher");
        }
    }
$-(if !virtual)$

    static iref<$name$> _generic_interface_creator(::$..nsx$$..class$* host, $name$* __here__)
    {
        iref<$name$> rval;

        $--(if ?varname)$
        //an active interface (with events)
        if (host->$varname$ && !__here__)
            rval = intergen_active_interface(host);

        if (rval.is_empty()) {
            //interface not taken from host
            $name$_dispatcher* dispatcher = __here__
                ? static_cast<$name$_dispatcher*>(__here__)
                : new $name$_dispatcher;
            rval.create(dispatcher);

            dispatcher->set_host(host, rval.get(), __here__ ? 0 : &rval);
        }
        $-(elif)$
        //a passive interface (no events)
        $name$_dispatcher* dispatcher = __here__
            ? static_cast<$name$_dispatcher*>(__here__)
            : new $name$_dispatcher;
        rval.create(dispatcher);

        dispatcher->set_host(host, 0, 0);
        $-(/if)$

        $-(if ?onconnect)$
        host->$onconnect$();

        $-(/if)$
        $-(if ?onconnectev)$
        rval->$onconnectev$();

        $-(/if)$
        return rval;
    }
$-(/if)$

public:

    // creator methods

$-[method ?creator !ifccr]$
    static iref<$..name$> $name$($..name$* __here__$[args]$, $type$ $name$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$)
    {
        iref<::$....nsx$$....class$> __host__ = ::$....nsx$$....class$::$intname$($[args rest=", "]$$name$$[/args]$);
        if (!__host__)
            return 0;
        return _generic_interface_creator(__host__.get(), __here__);
    }

$-[/method]$
    ///Register interface creators in the global registry
    static void register_interfaces(bool on)
    {
$-(if !virtual)$
        interface_register::register_interface_creator("$ns suffix="::"$$name$@wrapper", on ? (void*)&_generic_interface_creator : nullptr, &ifc_meta);

$-(/if)$
$-(if ?onunload)$
        static_assert(std::is_same<decltype(&::$..nsx$$..class$::$onunload$), intergen_interface::fn_unload_client>::value,
            "expected unload function to have (const coid::token& client, const coid::token& module, int mode) parameters");

        interface_register::register_interface_creator("$ns suffix="::"$$name$@unload", on ? (void*)&::$..nsx$$..class$::$onunload$ : nullptr, &ifc_meta);

$-(/if)$
$-[method ?creator !ifccr]$
        interface_register::register_interface_creator("$..ns suffix="::"$$..name$.$name$@$..hash$", on ? (void*)&$name$ : nullptr, &ifc_meta);
$-[/method]$
$-[method ?creator ?ifccr]$
        interface_register::register_interface_creator("$..ns suffix="::"$$..name$.$name$@$..hash$.ifc", on ? (void*)&::$....nsx$$....class$::$name$ : nullptr, &ifc_meta);
$-[/method]$
    }
};

$-(if ?varname)$

iref<$name$> $name$::intergen_active_interface(::$classnsx suffix="::"$$class$* host)
{
    coid::comm_mutex& mx = share_lock();

    GUARDTHIS(mx);
    iref<$name$> rval;
    rval.add_refcount(static_cast<$name$*>(host->$varname$.get()));

    return rval;
}

bool $name$::assign_safe(intergen_interface* client__, iref<$name$>* pout)
{
    //try assigning to the host (MT guard)
    // if that fails, the interface will be passive (no events)

    ::$..nsx$$..class$* hostptr = host<::$..nsx$$..class$>();
    if (!hostptr)
        return false;

    coid::clean_ptr<intergen_interface>& ifcvar = hostptr->$varname$;
    coid::comm_mutex& mx = share_lock();
    if (ifcvar == client__)
        return true;

    GUARDTHIS(mx);
    //assign only if nobody assigned before us
    bool succ = !ifcvar || !client__;
    if (succ) {
        ifcvar = client__;
        _cleaner = client__ ? &_cleaner_callback : 0;
    }
    else if (pout)
        pout->add_refcount(static_cast<$name$*>(ifcvar.get()));

    return succ;
}
$-(/if)$

bool $name$::set_host(policy_intrusive_base* host__, intergen_interface* client__, iref<$name$>* pout)
{
    _host = host__;
    _vtable = $name$_dispatcher::get_vtable();
$-(if ?varname)$

    return assign_safe(client__, pout);
$-(elif)$
    return true;
$-(/if)$
}

//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&$name$_dispatcher::register_interfaces);

void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&$name$_dispatcher::register_interfaces);
    return autoregger.get();
}

$-[ns]$
} //namespace $@value$
$-[/ns]$

$-(if ?event)$
// events

$[..nss]$namespace $@value$ {
$[/..nss]-$

$-[event !implicit !inherit]$
$return.type$ $....class$::$intname$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if ?fnarg)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if ?const)$ const$(/if)$
{
    if (!$..varname$ $-(if ?..inhmask)$ || ($..varname$->iface<$..ns suffix="::"$$..name$>()->_inhmask & (1<<$..ifc_bit$)) == 0$(/if)$) $-(if ?default_event_body)$
        { $default_event_body$ }$(elif)$
        throw coid::exception("Client not connected! ($name$)");$(/if)$
    else
        return $..varname$->iface<$..ns suffix="::"$$..name$>()->$name$($[args rest=", "]$$name$$[/args]$);
}
$[/event]-$

$[..nss]$} //namespace $@value$
$[/..nss]-$
$(/if)-$

$-[/iface]$
$-[iface_data]$
////////////////////////////////////////////////////////////////////////////////
// data interface $[ns]$$@value$::$[/ns]$$name$ of class $..nsx$$..class$
$[ns]$
namespace $@value$ {
$-[/ns]$

///
class $name$_data_dispatcher : public $name$
{
private:

    inline static ifn_t _fn_table[] = {$-[method !static]$
        reinterpret_cast<ifn_t>(($return.type$(intergen_data_interface::*)($[args rest=","]$ $-(if ?fnarg)$$type$($memfnclass after="::"$*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$)$(if ?const)$const$(/if)$)(&::$....nsx$$....class$::$intname$)),
$-[/method]$
        nullptr
    };
    inline static icr_t _cr_table[] = {$-[method ?creator !ifccr]$
        reinterpret_cast<icr_t>(&::$....nsx$$....class$::$intname$),
$-[/method]$
        nullptr
    };
$-[event ?pure]$

    $return.type$ $name$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if ?fnarg)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if ?const)$ const$(/if)$ override { throw coid::exception("unreachable"); }
$-[/event]$

protected:

    COIDNEWDELETE($name$_data_dispatcher);

    $name$_data_dispatcher() = default;
    ~$name$_data_dispatcher() = default;

public:

    static void register_interfaces(bool on)
    {
        coid::ifcman::set_type_ifc<$name$>(HASHID, _cr_table, _fn_table);
    }
};


//auto-register the available interface creators
LOCAL_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&$name$_data_dispatcher::register_interfaces);

void* force_register_$name$() {
    LOCAL_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&$name$_data_dispatcher::register_interfaces);
    return autoregger.get();
}

$-[ns]$
} //namespace $@value$
$-[/ns]$

$-(if ?event)$
// events

$[..nss]$namespace $@value$ {
$[/..nss]-$

$-[event !implicit !inherit]$
$return.type$ $....class$::$intname$($[args rest="," after=" "]$ $ifckwds after=" "$$type$ $(if ?fnarg)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if ?const)$ const$(/if)$
{
    if (!$..varname$ $-(if ?..inhmask)$ || ($..varname$->iface<$..ns suffix="::"$$..name$>()->_inhmask & (1<<$..ifc_bit$)) == 0$(/if)$) $-(if ?default_event_body)$
        { $default_event_body$ }$(elif)$
        throw coid::exception() << "$name$" << " handler not implemented";$(/if)$
    else
        return $..varname$->iface<$..ns suffix="::"$$..name$>()->$name$($[args rest=", "]$$name$$[/args]$);
}
$[/event]-$

$[..nss]$} //namespace $@value$
$[/..nss]-$
$(/if)-$

$-[/iface_data]$
$-[/class]$


//@file $name$ javascript interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

$-[class]$$[iface]$
#include "$relpathjs$"
$-[/iface]$
$-[iface_data]$
#include "$relpath$"
$-[/iface_data]$$[/class]$
#include "$hdr$"
$-[pastedefers]$

$@value$
$-[/pastedefers]$

#include <comm/intergen/ifc.js.h>
#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_v8.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

using namespace coid;
$-[class]$$[iface rest="\n\n"]$

////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface $name$ of class $..nsx$$..class$
//
////////////////////////////////////////////////////////////////////////////////
$[ns]$
namespace $@value$ {
$-[/ns]$
namespace js {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$_js_dispatcher
    : public ::js::interface_wrapper_base<::$ns suffix="::"$$name$>
{
$-(if ?event)$
    mutable v8::Persistent<v8::Function> _events[$event.@size$];
    mutable bool _bound_events;

$-(/if)$
$-(if ?hasprops)$
    static void _getter(v8::Local<v8::Name> property, const v8::ACCESSOR &info);
    static void _setter(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const v8::ACCESSOR &info);

$-(/if)$
    static void _js_release_callback(const v8::WeakCallbackInfo<$name$_js_dispatcher>& data)
    {
        $name$_js_dispatcher* ifc = data.GetParameter();
        ifc->_object.Reset();
        ifc->release_refcount();
    }

protected:

    backend intergen_backend() const override { return backend::js; }

public:

    v8::Handle<v8::Object> create_interface_object(v8::Handle<v8::Context> context, bool make_weak);

    static v8::Handle<v8::Script> load_script(const coid::token& script, const coid::token& file_name);
$-(if ?event)$
    void bind_events(v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref) const;
$-(/if)$

    COIDNEWDELETE($name$_js_dispatcher);

    $name$_js_dispatcher() $-(if ?event)$ : _bound_events(false)$(/if)$
    {}

    explicit $name$_js_dispatcher($ns suffix="::"$$name$* orig) $(if ?event)$: _bound_events(false) $(/if)${
        _base.create(orig);
        _vtable = _base->vtable();

        _host = _base->host<policy_intrusive_base>();
    }

    explicit $name$_js_dispatcher(policy_intrusive_base* host) $-(if ?event)$ : _bound_events(false)$(/if)$ {
        set_host(host, this, 0);
    }

    ~$name$_js_dispatcher()
    {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        v8::HandleScope handle_scope__(iso);

$-(if ?event)$
        for (int i=0; i<$event.@size$; ++i) {
            _events[i].Reset();
        }

$-(/if)$
        if (!_object.IsEmpty()) {
            _object.Get(iso)->SetInternalField(0, v8::Null(iso));
        }

        _object.Reset();
    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- creators ---

$-[method ?creator]$
$(if !comments.empty)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$_js_dispatcher> $name$(const ::js::script_handle& scriptpath
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, v8::Handle<v8::Context>*);

    $-(if !internal)$
    static v8::Handle<v8::Value> v8creator_$name$$@order$(const v8::ARGUMENTS& args);

    $-(/if)$
$-[/method]$
    static void v8rebind_events(const v8::ARGUMENTS& args);
    static void v8current_global(const v8::ARGUMENTS& args);

    // --- method wrappers ---

$-[method !static !destroy !internal !operator]$
    static void v8_$name$$@order$(const v8::ARGUMENTS& args);
$-[/method]$
$-(if !event.empty)$

    // --- interface events ---

$-[event]$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $(if ?fnarg)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$) $-(if ?const)$ const$(/if)$ override;
$-[/event]$

    virtual bool is_bound(event m) override {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        if (!_bound_events) {
            v8::HandleScope handle_scope__(iso);
            v8::TryCatch js_trycatch(iso);

            bind_events(context(iso), false, v8::Undefined(iso));
        }

        int id = int(m);
        return !_events[id].IsEmpty() && !_events[id].Get(iso)->IsUndefined();
    }

    virtual void force_bind_script_events() {
        v8::Isolate* iso = v8::Isolate::GetCurrent();
        v8::HandleScope handle_scope__(iso);
        v8::TryCatch js_trycatch(iso);

        bind_events(context(iso), true, v8::Local<v8::Value>());
    }

private:

    //event wrappers for event invocation from js
$-[event]$
    static void v8_evback_$name$$@order$(const v8::ARGUMENTS& args);
$-[/event]$
$-(/if)$
};

$-[method !static !destroy !internal !operator]$
////////////////////////////////////////////////////////////////////////////////
void $..name$_js_dispatcher::v8_$name$$@order$(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < $ninargs_nondef$ || args.Length() > $ninargs$) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "$..name$.$name$";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    ::js::interface_wrapper_base<$..ns rest="::"$::$..name$>* ifc = static_cast<::js::interface_wrapper_base<$..ns rest="::"$::$..name$>*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$.$name$";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in
$-[args ?inarg !nojs]$
  $-(if !iref)$
        static_assert(coid::has_metastream_operator<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$>::value, "missing metastream operator for '$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$'");
  $-(/if)$
$-[/args]$

$-[args ?inarg !nojs]$
  $-(if !defval.empty ?ptr)$
        threadcached<$basetype$> $name$__tmp;
        $basetype$ *$name$ = &$name$__tmp;
        if ($@order$ < args.Length())
            write_from_v8(args[$@order$], $name$__tmp);
        else
            $name$ = $defval$;
  $-(elif !defval.empty)$
        threadcached<$basetype$> $name$;
        if ($@order$ < args.Length())
            write_from_v8(args[$@order$], $name$);
        else
            $name$ = $defval$;
  $-(elif)$
        threadcached<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$> $name$;
        write_from_v8(args[$@order$], $name$);
  $-(/if)$
$-[/args]$

        //invoke
$-[args ?outarg !inarg]$
        $basetype$ $name$;
$-[/args]$
        $(if !return.type="void")$$return.type$ _rval_ = $(/if)$R_->$name$($[args rest=", "]$ $-(if ?ptr ?outarg)$&$-(elif ?ptr ?defval.empty !specptr)$&$(/if)$ $-(if ?nojs)$$defval$$(elif)$$name$$(/if)$$[/args]$);

        //stream out
$-(if !return.type="void")$
 $-(if !retifc ?noutargs)$
        static_assert(coid::has_metastream_operator<$return.type$>::value, "missing metastream operator for '$return.type$'");
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        r__->Set(ctx, v8::symbol("$$ret", iso), read_to_v8(_rval_));
 $-(elif ?noutargs)$
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        r__->Set(ctx, v8::symbol("$$ret", iso), ::js::wrap_interface(_rval_.get(), ifc->context(iso)));
 $-(elif !retifc)$
        v8::Handle<v8::Value> r__;
  $-(if ?return.ptr)$
        static_assert(coid::has_metastream_operator<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'");
        if (_rval_)
            r__ = read_to_v8(*_rval_);
  $-(elif)$
        static_assert(coid::has_metastream_operator<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'");
        r__ = read_to_v8(_rval_);
  $-(/if)$
 $-(elif ?return.ifc_type="1")$
        v8::Handle<v8::Value> r__ = ::js::wrap_interface(_rval_.get(), ifc->context(iso));
 $-(elif ?return.ifc_type="2")$
        v8::Handle<v8::Value> r__ = ::js::wrap_data_interface<$return.basetype$>(_rval_, "$return.basetype$"_T, ifc->context(iso));
 $-(/if)$

 $-[args ?outarg]$
  $-(if !ifc_type)$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        r__->Set(ctx, v8::symbol("$name$", iso), read_to_v8($name$));
  $-(elif)$
        r__->Set(ctx, v8::symbol("$name$", iso), ::js::wrap_interface($name$.get(), ifc->context(iso)));
  $-(/if)$
 $-[/args]$
$-(elif ?noutargs="1")$
 $-[args ?outarg]$
  $-(if !ifc_type)$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        v8::Handle<v8::Value> r__ = read_to_v8($name$);
  $-(elif)$
        v8::Handle<v8::Value> r__ = ::js::wrap_interface(_rval_.get(), ifc->context(iso));
  $-(/if)$
 $-[/args]$
$-(elif ?noutargs)$
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
 $-[args ?outarg]$
  $-(if !ifc_type)$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        r__->Set(ctx, v8::symbol("$name$", iso), read_to_v8($name$));
  $-(elif)$
        r__->Set(ctx, v8::symbol("$name$", iso), ::js::wrap_interface($name$.get(), ifc->context(iso)));
  $-(/if)$
 $-[/args]$
$-(elif)$
        v8::Handle<v8::Object> r__;
$(/if)-$

        args.GetReturnValue().Set(r__);
    }
    catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

$-[/method]$
$-[event]$
////////////////////////////////////////////////////////////////////////////////
$return.type$ $..name$_js_dispatcher::$name$($[args rest="," after=" "]$ $type$ $(if ?fnarg)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if ?const)$ const$(/if)$
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

$-(if ?internal)$
    throw coid::exception("method not marked for scripting");
$-(elif)$
    v8::HandleScope handle_scope__(iso);
    v8::Handle<v8::Context> ctx__ = context(iso);
    v8::Context::Scope context_scope__(ctx__);
    v8::TryCatch js_trycatch__(iso);

    bind_events(ctx__, false, v8::Undefined(iso));
    auto ev__ = _events[$@order$].Get(iso);

    if (_events[$@order$].IsEmpty() || ev__->IsUndefined())
  $-(if ?default_event_body)$ {
        $default_event_body$; $-(if ?return.type="void")$
        return;
        $-(/if)$
    }
  $-(elif !noevbody)$
        return;
  $-(elif)$
        throw coid::exception("handler not implemented");
  $-(/if)$

// prepare in arguments
$-[args ?inarg !iref]$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
$-[/args]$
$-(if ?ninargs)$
    v8::Handle<v8::Value> __inargs[] = {
$-[args ?inarg rest=","]$
        to_v8$(if ?volatile)$_volatile$(/ if)$<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$>::read($name$)
$-[/args]$
    };

$-(/if)$
//  event call
    v8::Local<v8::Value> r__ = ev__->Call(
        ctx__,
        _object.Get(iso),
        $(if ?ninargs)$$ninargs$, __inargs$(elif)$0, 0$(/if)$).ToLocalChecked();

$-[args ?inarg]$$(if ?volatile)$
    to_v8$(if ?volatile)$_volatile$(/if)$<$basetype$>::cleanup(__inargs[$@order$]);$(/if)$
$-[/args]$

    if (js_trycatch__.HasCaught())
        ::js::script_handle::throw_exception_from_js_error(js_trycatch__, "$..ns suffix="::"$js::$..name$.$name$");
// gather results
$-(if !noutargs)$

 $-(if !return.type="void")$
  $-(if ?retifc)$
    $return.type$ _rval_;
  $-(elif)$
    static_assert(coid::has_metastream_operator<$return.type$>::value, "missing metastream operator for '$return.type$'");
    threadcached<$return.type$> _rval_;
  $-(/if)$
    write_from_v8(r__, _rval_);
 $-(/if)$
$-(elif)$
 $-(if ?return.type="void" ?noutargs="1")$

  $-[args ?outarg]$
   $-(if !iref)$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
   $-(/if)$
   $-(if ?ptr)$
    if ($name$)
        write_from_v8(r__, *$name$);
   $-(elif)$
    write_from_v8(r__, $name$);
   $-(/if)$
  $-[/args]$
 $-(elif)$

    if (!r__->IsObject()) throw coid::exception("invalid params");
    v8::Local<v8::Object> obj__ = r__->ToObject(ctx__).ToLocalChecked();
  $-(if !return.type="void")$

    //return value
   $-(if ?retifc)$
    $return.type$ _rval_;
    write_from_v8(r__, _rval_);
   $-(elif)$
    static_assert(coid::has_metastream_operator<$return.type$>::value, "missing metastream operator for '$return.type$'");
    threadcached<$return.type$> _rval_;
    write_from_v8(obj__->Get(ctx__, v8::symbol("$$ret", iso)).ToLocalChecked(), _rval_);
   $-(/if)$
  $-(/if)$
  $-[args ?outarg]$

   $-(if !iref)$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
   $-(/if)$
   $-(if ?ptr)$
    if ($name$)
        write_from_v8(obj__->Get(ctx__, v8::symbol("$name$", iso)).ToLocalChecked(), *$name$);
   $-(elif)$
    write_from_v8(obj__->Get(ctx__, v8::symbol("$name$", iso)).ToLocalChecked(), $name$);
   $-(/if)$
  $-[/args]$
 $-(/if)$
$(/if)-$

$-(if !return.type="void")$
    return _rval_;
$-(/if)$
$-(/if)$
}

////////////////////////////////////////////////////////////////////////////////
void $..name$_js_dispatcher::v8_evback_$name$$@order$(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $..ns suffix="::"$js::$..name$_js_dispatcher* ifc = static_cast<$..ns suffix="::"$js::$..name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    v8::Handle<v8::Context> ctx = ifc->context(iso);
    v8::Context::Scope context_scope(ctx);
    v8::TryCatch js_trycatch(iso);

    ifc->bind_events(ctx, false, v8::Undefined(iso));
    auto ev__ = ifc->_events[$@order$].Get(iso);

    if (ifc->_events[$@order$].IsEmpty() || ev__->IsUndefined()) {
        coid::charstr tmp = "Event not available: ";
        tmp << "$name$";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }
$-(if ?ninargs.nonzero)$

    v8::Local<v8::Value> largs[$ninargs$];
    int nargs = args.Length();
    if (nargs > $ninargs$)
        nargs = $ninargs$;
    for (int i=0; i<nargs; ++i)
        largs[i] = args[i];
$-(/if)$

    v8::Local<v8::Value> r__ = ev__->Call(
        ctx,
        ifc->_object.Get(iso),
        $(if ?ninargs)$nargs, largs$(elif)$0, 0$(/if)$).ToLocalChecked();

    args.GetReturnValue().Set(r__);
}

$-[/event]$
$-(if ?hasprops)$
////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::_getter(v8::Local<v8::Name> property, const v8::ACCESSOR& args)
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $ns suffix="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns suffix="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$[]";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));

    v8::String::Utf8Value key(iso, property);
    coid::token tok(*key, key.length());

 $-(if ?getter.token)$
    $getter.basetype$ value = (*R_)(tok);
 $-(elif)$
    $getter.basetype$ value = (*R_)(*key);
 $-(/if)$

    //stream out
 $-(if !getter.ifc_type)$
    static_assert(coid::has_metastream_operator<$getter.basetype$>::value, "missing metastream operator for '$getter.basetype$'");
    v8::Handle<v8::Value> r__ = read_to_v8(value);
 $-(elif)$
    v8::Handle<v8::Value> r__ = ::js::wrap_interface(value.get(), ifc->context(iso));
 $-(/if)$

    args.GetReturnValue().Set(r__);
}

////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::_setter(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const v8::ACCESSOR& args)
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $ns suffix="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns suffix="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    auto R_ = ifc ? ifc->_real() : 0;
    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$[] = ...";
        return v8::queue_js_exception(iso, v8::Exception::ReferenceError, tmp);
    }

    v8::Context::Scope context_scope(ifc->context(iso));
    static_assert(coid::has_metastream_operator<$setter.basetype$>::value, "missing metastream operator for '$setter.basetype$'");
    threadcached<$setter.basetype$> val;
    write_from_v8(value, val);

    v8::String::Utf8Value key(iso, property);
    try {
$-(if ?setter.token)$
        (*R_)(coid::token(*key, key.length()), val);
$-(elif)$
        (*R_)(*key, val);
$-(/if)$
    }
    catch (std::exception& e)
    {
        v8::queue_js_exception(iso,v8::Exception::Error,e.what());
    }
    args.GetReturnValue().Set(value);
}
$-(/if)$

////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::v8rebind_events(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

$-(if ?event)$
    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $ns suffix="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns suffix="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    if (ifc) {
        v8::Local<v8::Value> val;
        if (args.Length() > 0)
            val = args[0];
        ifc->bind_events(ifc->context(iso), true, val);
    }

$-(/if)$
    return (void)args.GetReturnValue().Set(v8::Undefined(iso));
}

////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::v8current_global(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $ns suffix="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns suffix="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(intobj__)->Value());

    args.GetReturnValue().Set(ifc->context(iso)->Global()->GetPrototype());
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> $name$_js_dispatcher::create_interface_object(v8::Handle<v8::Context> context, bool make_weak)
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if (_objtempl.IsEmpty())
    {
        v8::Local<v8::ObjectTemplate> ot = v8::ObjectTemplate::New(iso);

        ot->Set(v8::Symbol::GetToStringTag(iso), v8::string_utf8("$ns suffix="::"$$name$"));
        ot->SetInternalFieldCount(2);    //ptr and class hash id

$-[method !static !destroy !internal !operator]$
        ot->Set(v8::symbol("$name$", iso), v8::FunctionTemplate::New(iso, &v8_$name$$@order$));
$-[/method]$

        ot->Set(v8::symbol("$$log", iso), v8::FunctionTemplate::New(iso, &::js::script_handle::log));
        ot->Set(v8::symbol("$$query_interface", iso), v8::FunctionTemplate::New(iso, &::js::script_handle::query_interface));
        ot->Set(v8::symbol("$$rebind_events", iso), v8::FunctionTemplate::New(iso, &v8rebind_events));
        ot->Set(v8::symbol("$$ctx", iso), v8::FunctionTemplate::New(iso, &v8current_global));
$-(if ?hasprops)$

        v8::NamedPropertyHandlerConfiguration conf(&_getter, &_setter);
        conf.flags = v8::PropertyHandlerFlags::kNonMasking;
        ot->SetHandler(conf);
$-(/if)$
$-(if ?event.nonzero)$

        //event wrappers for event invocation from outside js
$-[event]$
        ot->Set(v8::symbol("$name$", iso), v8::FunctionTemplate::New(iso, &v8_evback_$name$$@order$));
$-[/event]$
$-(/if)$

        _objtempl.Reset(iso, ot);
    }

    v8::Context::Scope ctxscope(context);
    v8::Local<v8::Object> obj = _objtempl.Get(iso)->NewInstance(context).ToLocalChecked();

    v8::Handle<v8::External> map_ptr = v8::External::New(iso, this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = v8::External::New(iso, (void*)ints($hash$));
    obj->SetInternalField(1, hash_ptr);

    if (make_weak) {
        _object.Reset(iso, obj);

        _object.SetWeak(this, _js_release_callback, v8::WeakCallbackType::kParameter);
        add_refcount();
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Script> $name$_js_dispatcher::load_script(const coid::token& script, const coid::token& fname)
{
    return ::js::script_handle::load_script(script, fname, ::js::rethrow_in_cxx);
}

$-(if !event.empty)$
////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::bind_events(v8::Handle<v8::Context> context, bool force, v8::Handle<v8::Value> ref) const
{
    if (!force && _bound_events)
        return;

    //check if the context is from a html window & wait for loaded state
    bool final_state = true;
    uint nf = context->GetNumberOfEmbedderDataFields();
    const uint* cs = nf > 3 ? (const uint*)context->GetAlignedPointerFromEmbedderData(3) : 0;
    if (cs && (*cs & ~1ULL) == 0xBB07F010ULL) {
        if ((*cs & 1) == 0)
            final_state = false;
    }

    v8::Isolate* iso = context->GetIsolate();

    static token names[] = {
$-[event]$
        "$name$"_T,
$-[/event]$
    };

    v8::HandleScope handle_scope__(iso);
    v8::Context::Scope context_scope__(context);
    v8::TryCatch js_trycatch(iso);
    v8::Local<v8::Object> global;

    bool clear = false;
    if (ref.IsEmpty() || ref->IsUndefined())
        global = context->Global();
    else if (ref->IsNull())
        clear = true;
    else
        global = ref->ToObject(context).ToLocalChecked();

    for (int i=0; i<$event.@size$; ++i)
    {
        _events[i].Reset();

        if (clear)
            continue;

        v8::Local<v8::Value> var = v8::get_value(global, names[i], context);
        if (var->IsUndefined())
            continue;

        v8::Local<v8::Function> foo = v8::Local<v8::Function>::Cast(var);
        bool failed = js_trycatch.HasCaught() || foo->IsUndefined();

        if (!failed)
             _events[i].Reset(iso, foo);
    }

    if (final_state)
        _bound_events = true;
}

$-(/if)$
// --- creators ---

$-[method ?creator]$
////////////////////////////////////////////////////////////////////////////////
iref<$..name$_js_dispatcher> $..name$_js_dispatcher::$name$(const ::js::script_handle& script
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, v8::Handle<v8::Context>* ctx)
{
    v8::Isolate* iso = script.has_context()
        ? script.context()->GetIsolate()
        : v8::Isolate::GetCurrent();

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Handle<v8::Context> context;

    // create interface object
    iref<$..name$_js_dispatcher> ifc = $..ns suffix="::"$$..name$::$name$(new $..name$_js_dispatcher$[args]$, $name$$[/args]$);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

    // check if an external context provider is required
    if (script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());

        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if (ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if (!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
            if (context.IsEmpty())
                throw coid::exception() << "unable to create context";
        }
    }

    bool extctx = !context.IsEmpty();

    if (!extctx) {
        if (script.has_context())
            context = script.context();
        else {
            context = v8::Context::New(iso);
            v8::Context::Scope context_scope(context);
            ::js::script_handle::register_global_context_methods(context->Global(), iso);
        }
    }

    //set early here as sometimes the invoked creator methods want to access it
    if (ctx)
        *ctx = handle_scope__.Escape(context);

    v8::Context::Scope context_scope(context);

    if (!extctx && !script.is_context())
    {
        coid::token script_tok;
        coid::charstr script_tmp;
        if (script.is_path()) {
            coid::bifstream bif (script.str());
            if (!bif.is_open())
                throw coid::exception() << script.str() << " not found";

            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);

            script_tok = script_tmp;
        }
        else if (script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
        }
        else {
            script_tok = script.str();
        }

        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));
        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script.url());
    }
    else {
        ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

        if (bindname)
            context->Global()->Set(context, v8::symbol(bindname, iso), ifc->_object.Get(iso));
    }

    return ifc;
}

$-(if !internal)$
////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> $..name$_js_dispatcher::v8creator_$name$$@order$(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < 1+$ninargs_nondef$ || args.Length() > 1+$ninargs$) { //fnc name + in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "$name$";
        v8::queue_js_exception(iso, &v8::Exception::Error, tmp);
        return v8::Undefined(iso);
    }

    v8::EscapableHandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();

    //$..ns suffix="::"$js::$..name$_js_dispatcher* ifc = static_cast<$..ns suffix="::"$js::$..name$_js_dispatcher*>
    //    (v8::Handle<v8::External>::Cast(obj__->GetInternalField(0))->Value());

    v8::Local<v8::Context> ctx = iso->GetCurrentContext();
    v8::Context::Scope context_scope(ctx);

    //stream the arguments in
$-[args ?inarg !nojs]$
  $-(if !iref)$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
  $-(/if)$
$-[/args]$
$-[args ?inarg !nojs]$
  $-(if ?ptr !defval.empty)$
    threadcached<$basetype$> $name$__tmp;
    $basetype$ *$name$ = &$name$__tmp;
    if (1 + $@order$ < args.Length())
        write_from_v8(args[1+$@order$], $name$__tmp);
    else
        $name$ = $defval$;
  $-(elif !defval.empty)$
    threadcached<$basetype$> $name$;
    if (1 + $@order$ < args.Length())
        write_from_v8(args[1+$@order$], $name$);
    else
        $name$ = $defval$;
  $-(elif)$
    threadcached<$basetype$> $name$;
    write_from_v8(args[1+$@order$], $name$);
  $-(/if)$
$-[/args]$

    //invoke
$-[args ?outarg !inarg]$
    $basetype$ $name$;
$-[/args]$

    iref<$..name$_js_dispatcher> nifc = $..ns suffix="::"$$..name$::$name$(new $..name$_js_dispatcher$[args]$, $(if ?ptr ?outarg)$&$(elif ?ptr ?defval.empty !specptr)$&$(/if)$$name$$[/args]$);

    //stream out
$-(if ?noutargs)$
    v8::Handle<v8::Object> r__ = v8::Object::New(iso);
    r__->Set(ctx, v8::symbol("$$ret", iso), nifc
        ? v8::Handle<v8::Value>(nifc->create_interface_object(ctx, true))
        : v8::Handle<v8::Value>(v8::Null(iso)));
$-(elif)$
    v8::Handle<v8::Value> r__ = nifc
        ? v8::Handle<v8::Value>(nifc->create_interface_object(ctx, true))
        : v8::Handle<v8::Value>(v8::Null(iso));
$-(/if)$

$-[args ?outarg]$
  $-(if !iref)$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
  $-(/if)$
    r__->Set(ctx, v8::symbol("$name$", iso), read_to_v8($name$));
$-[/args]$

    return handle_scope__.Escape(r__);
}

$-(/if)$
$-[/method]$
$-(if !virtual)$
////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> wrap_ifc_to_js_$name$(::$ns suffix="::"$$name$* orig_ifc, v8::Handle<v8::Context> context)
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    // check that the orig_ifc points to an object
    if (!orig_ifc)
        return v8::Null(iso);

    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    v8::Context::Scope context_scope(context);
    v8::EscapableHandleScope scope(iso);

    iref<$ns suffix="::"$js::$name$_js_dispatcher> ifc;
    v8::Handle<v8::Object> obj;

    if (orig_ifc->intergen_backend() == intergen_interface::backend::js)
        obj = static_cast<$name$_js_dispatcher*>(orig_ifc)->_object.Get(iso);

    if (obj.IsEmpty()) {
        // create interface object
        ifc.create(new $ns suffix="::"$js::$name$_js_dispatcher(static_cast<::$ns suffix="::"$$name$*>(orig_ifc)));

        obj = ifc->create_interface_object(context, true);
    }

    return scope.Escape(obj);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS interface from a host
static iref<$ns suffix="::"$js::$name$_js_dispatcher> make_js_ifc_from_host_$name$(policy_intrusive_base* host, v8::Handle<v8::Context> context)
{
    v8::Isolate* iso = context.IsEmpty() ? v8::Isolate::GetCurrent() : context->GetIsolate();
    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    // check that the orig points to an object
    if (!host)
        return 0;

    v8::Context::Scope context_scope(context);
    v8::HandleScope scope(iso);

    // create interface object
    iref<$ns suffix="::"$js::$name$_js_dispatcher> ifc;
    ifc.create(new $ns suffix="::"$js::$name$_js_dispatcher(host));

    ifc->_object.Reset(iso, ifc->create_interface_object(context, false));

    return ifc;
}

$-(/if)$
////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_$name$(bool on)
{
$-[method ?creator]$
    //c++ creator of JS interface object
    interface_register::register_interface_creator("$..ns suffix="::"$$..name$.$name$@creator.js", on ? (void*)&$..name$_js_dispatcher::$name$ : nullptr, nullptr);
$-(if !internal)$

    //creator from script
    interface_register::register_interface_creator("$..ns suffix="::"$js::$..name$.$name$", on ? (void*)&$..name$_js_dispatcher::v8creator_$name$$@order$ : nullptr, nullptr);
$-(/if)$
$-[/method]$
$-(if !virtual)$

    //wrapper interface creator from existing js/c++ interface
    interface_register::register_interface_creator("$ns suffix="::"$$name$@wrapper.js", on ? (void*)&wrap_ifc_to_js_$name$ : nullptr, nullptr);

    //js interface creator from host
    interface_register::register_interface_creator("$ns suffix="::"$$name$@maker.js", on ? (void*)&make_js_ifc_from_host_$name$ : nullptr, nullptr);
$-(/if)$
}

//auto-register the bind function
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&register_binders_for_$name$);


void* force_register_$name$() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_$name$);
    return autoregger.get();
}

} //namespace js
$-[ns]$
} //namespace $@value$
$-[/ns]$

$-[/iface]$
$[iface_data rest="\n\n"]$

////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of data interface $name$ of class $..nsx$$..class$
//
////////////////////////////////////////////////////////////////////////////////
$[ns]$
namespace $@value$ {
$-[/ns]$
namespace js {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$_js_dispatcher
    : public ::js::interface_context
{
$-(if ?hasprops)$
    static void _getter(v8::Local<v8::Name> property, const v8::ACCESSOR &info);
    static void _setter(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const v8::ACCESSOR &info);

$-(/if)$
public:

    v8::Handle<v8::Object> create_interface_object(v8::Handle<v8::Context> context);

    COIDNEWDELETE($name$_js_dispatcher);

    //$name$_js_dispatcher()
    //{}

    explicit $name$_js_dispatcher(::$..nsx$$..class$* host)
    {
        ifc = entman::get_versionid<::$..nsx$$..class$>(host);
    }

    explicit $name$_js_dispatcher(const coref<$name$>& ifc) : ifc(ifc)
    {}

    ~$name$_js_dispatcher()
    {}

    // --- creators ---

$-[method ?creator]$
$(if !comments.empty)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$_js_dispatcher> $name$(const ::js::script_handle& scriptpath
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, v8::Handle<v8::Context>*);

    $-(if !internal)$
    static v8::Handle<v8::Value> v8creator_$name$$@order$(const v8::ARGUMENTS& args);

    $-(/if)$
$-[/method]$
    // --- method wrappers ---

$-[method !static !destroy !internal !operator]$
    static void v8_$name$$@order$(const v8::ARGUMENTS& args);
$-[/method]$

private:

    coref<$name$> ifc;
};

$-[method !static !destroy !internal !operator]$
////////////////////////////////////////////////////////////////////////////////
void $..name$_js_dispatcher::v8_$name$$@order$(const v8::ARGUMENTS& args)
{
    v8::Isolate* iso = args.GetIsolate();

    if (args.Length() < $ninargs_nondef$ || args.Length() > $ninargs$) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "$..name$.$name$";
        return v8::queue_js_exception(iso, v8::Exception::SyntaxError, tmp);
    }

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $..name$_js_dispatcher* disp_ = static_cast<$..name$_js_dispatcher*>(v8::Handle<v8::External>::Cast(intobj__)->Value());
    $..name$* R_ = disp_->ifc.ready();

    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$.$name$";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::Local<v8::Context> ctx = iso->GetCurrentContext();
    v8::Context::Scope context_scope(ctx);

    try {
        //stream the arguments in
$-[args ?inarg !nojs]$
  $-(if !iref)$
        static_assert(coid::has_metastream_operator<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$>::value, "missing metastream operator for '$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$'");
  $-(/if)$
$-[/args]$

$-[args ?inarg !nojs]$
  $-(if !defval.empty ?ptr)$
        threadcached<$basetype$> $name$__tmp;
        $basetype$ *$name$ = &$name$__tmp;
        if ($@order$ < args.Length())
            write_from_v8(args[$@order$], $name$__tmp);
        else
            $name$ = $defval$;
  $-(elif !defval.empty)$
        threadcached<$basetype$> $name$;
        if ($@order$ < args.Length())
            write_from_v8(args[$@order$], $name$);
        else
            $name$ = $defval$;
  $-(elif)$
        threadcached<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$> $name$;
        write_from_v8(args[$@order$], $name$);
  $-(/if)$
$-[/args]$

        //invoke
$-[args ?outarg !inarg]$
        $basetype$ $name$;
$-[/args]$

        $(if !return.type="void")$$return.type$ _rval_ = $(/if)$R_->$intname$($[args rest=", "]$ $-(if ?ptr ?outarg)$&$-(elif ?ptr ?defval.empty !specptr)$&$(/if)$ $-(if ?nojs)$$defval$$(elif)$$name$$(/if)$$[/args]$);

        //stream out
$-(if !return.type="void")$
 $-(if !retifc ?noutargs)$
        static_assert(coid::has_metastream_operator<$return.type$>::value, "missing metastream operator for '$return.type$'");
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        r__->Set(ctx, v8::symbol("$$ret", iso), read_to_v8(_rval_));
 $-(elif ?noutargs)$
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
        r__->Set(ctx, v8::symbol("$$ret", iso), ::js::wrap_interface(_rval_.get(), ifc->context(iso)));
 $-(elif !retifc)$
        v8::Handle<v8::Value> r__;
  $-(if ?return.ptr)$
        static_assert(coid::has_metastream_operator<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'");
        if (_rval_)
            r__ = read_to_v8(*_rval_);
  $-(elif)$
        static_assert(coid::has_metastream_operator<$return.basetype$>::value, "missing metastream operator for '$return.basetype$'");
        r__ = read_to_v8(_rval_);
  $-(/if)$
 $-(elif ?return.ifc_type="1")$
        v8::Handle<v8::Value> r__ = ::js::wrap_interface(_rval_.get(), ifc->context(iso));
 $-(elif ?return.ifc_type="2")$
        v8::Handle<v8::Value> r__ = ::js::wrap_data_interface<$return.basetype$>(_rval_.ready(), "$return.basetype$"_T, ifc->context(iso));
 $-(/if)$

 $-[args ?outarg]$
  $-(if !ifc_type)$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        r__->Set(ctx, v8::symbol("$name$", iso), read_to_v8($name$));
  $-(elif)$
        r__->Set(ctx, v8::symbol("$name$", iso), ::js::wrap_interface($name$.get(), ifc->context(iso)));
  $-(/if)$
 $-[/args]$
$-(elif ?noutargs="1")$
 $-[args ?outarg]$
  $-(if !ifc_type)$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        v8::Handle<v8::Value> r__ = read_to_v8($name$);
  $-(elif)$
        v8::Handle<v8::Value> r__ = ::js::wrap_interface(_rval_.get(), ifc->context(iso));
  $-(/if)$
 $-[/args]$
$-(elif ?noutargs)$
        v8::Handle<v8::Object> r__ = v8::Object::New(iso);
 $-[args ?outarg]$
  $-(if !ifc_type)$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        r__->Set(ctx, v8::symbol("$name$", iso), read_to_v8($name$));
  $-(elif)$
        r__->Set(ctx, v8::symbol("$name$", iso), ::js::wrap_interface($name$.get(), ifc->context(iso)));
  $-(/if)$
 $-[/args]$
$-(elif)$
        v8::Handle<v8::Object> r__;
$(/if)-$

        args.GetReturnValue().Set(r__);

    }
    catch (const coid::exception& e) {
        return v8::queue_js_exception(iso, &v8::Exception::TypeError, e.text());
    }
}

$-[/method]$
$-(if ?hasprops)$
////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::_getter(v8::Local<v8::Name> property, const v8::ACCESSOR& args)
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $..name$_js_dispatcher* disp_ = static_cast<$..name$_js_dispatcher*>(v8::Handle<v8::External>::Cast(intobj__)->Value());
    ::$....nsx$$....class$* R_ = disp_->ifc.ready();

    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$[]";
        return v8::queue_js_exception(iso, &v8::Exception::ReferenceError, tmp);
    }

    v8::String::Utf8Value key(iso, property);
    coid::token tok(*key, key.length());

 $-(if ?getter.token)$
    $getter.basetype$ value = (*R_)(tok);
 $-(elif)$
    $getter.basetype$ value = (*R_)(*key);
 $-(/if)$

    //stream out
 $-(if !getter.ifc_type)$
    static_assert(coid::has_metastream_operator<$getter.basetype$>::value, "missing metastream operator for '$getter.basetype$'");
    v8::Handle<v8::Value> r__ = read_to_v8(value);
 $-(elif)$
    v8::Handle<v8::Value> r__ = ::js::wrap_interface(value.get(), ifc->context(iso));
 $-(/if)$

    args.GetReturnValue().Set(r__);
}

////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::_setter(v8::Local<v8::Name> property, v8::Local<v8::Value> value, const v8::ACCESSOR& args)
{
    v8::Isolate* iso = args.GetIsolate();

    v8::HandleScope handle_scope__(iso);
    v8::Local<v8::Object> obj__ = args.Holder();
    if (obj__.IsEmpty() || obj__->InternalFieldCount() == 0)
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    v8::Local<v8::Value> intobj__ = obj__->GetInternalField(0);
    if (!intobj__->IsExternal())
        return (void)args.GetReturnValue().Set(v8::Undefined(iso));

    $..name$_js_dispatcher* disp_ = static_cast<$..name$_js_dispatcher*>(v8::Handle<v8::External>::Cast(intobj__)->Value());
    ::$....nsx$$....class$* R_ = disp_->ifc.ready();

    if (!R_) {
        coid::charstr tmp = "Null interface object in ";
        tmp << "$..name$[] = ...";
        return v8::queue_js_exception(iso, v8::Exception::ReferenceError, tmp);
    }

    static_assert(coid::has_metastream_operator<$setter.basetype$>::value, "missing metastream operator for '$setter.basetype$'");
    threadcached<$setter.basetype$> val;
    write_from_v8(value, val);

    v8::String::Utf8Value key(iso, property);
    try {
$-(if ?setter.token)$
        (*R_)(coid::token(*key, key.length()), val);
$-(elif)$
        (*R_)(*key, val);
$-(/if)$
    }
    catch (std::exception& e)
    {
        v8::queue_js_exception(iso,v8::Exception::Error,e.what());
    }
    args.GetReturnValue().Set(value);
}
$-(/if)$


////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> $name$_js_dispatcher::create_interface_object(v8::Handle<v8::Context> context)
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if (_objtempl.IsEmpty())
    {
        v8::Local<v8::ObjectTemplate> ot = v8::ObjectTemplate::New(iso);

        ot->Set(v8::Symbol::GetToStringTag(iso), v8::string_utf8("$ns suffix="::"$$name$"));
        ot->SetInternalFieldCount(2);    //ptr and class hash id

$-[method !static !destroy !internal !operator]$
        ot->Set(v8::symbol("$name$", iso), v8::FunctionTemplate::New(iso, &v8_$name$$@order$));
$-[/method]$
$-(if ?hasprops)$

        v8::NamedPropertyHandlerConfiguration conf(&_getter, &_setter);
        conf.flags = v8::PropertyHandlerFlags::kNonMasking;
        ot->SetHandler(conf);
$-(/if)$

        _objtempl.Reset(iso, ot);
    }

    v8::Context::Scope ctxscope(context);
    v8::Local<v8::Object> obj = _objtempl.Get(iso)->NewInstance(context).ToLocalChecked();

    v8::Handle<v8::External> map_ptr = v8::External::New(iso, this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = v8::External::New(iso, (void*)ints($hash$));
    obj->SetInternalField(1, hash_ptr);

    return obj;
}

$-(if !virtual)$
////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from an existing interface object
v8::Handle<v8::Value> wrap_ifc_to_js_$name$(const coref<$name$>& orig_ifc, v8::Handle<v8::Context> context)
{
    v8::Isolate* iso = v8::Isolate::GetCurrent();

    // check that the orig points to an object
    if (!orig_ifc)
        return v8::Null(iso);

    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    v8::Context::Scope context_scope(context);
    v8::EscapableHandleScope scope(iso);
    
    // create interface object
    $ns suffix="::"$js::$name$_js_dispatcher* difc = new $ns suffix="::"$js::$name$_js_dispatcher(orig_ifc);

    v8::Handle<v8::Value> r__ = v8::Handle<v8::Value>(difc->create_interface_object(context));
    return scope.Escape(r__);
}

////////////////////////////////////////////////////////////////////////////////
///Create JS interface from a host
static iref<$ns suffix="::"$js::$name$_js_dispatcher> make_js_ifc_from_host_$name$(::$..nsx$$..class$* host, v8::Handle<v8::Context> context)
{
    // check that the orig points to an object
    v8::Isolate* iso = context.IsEmpty() ? v8::Isolate::GetCurrent() : context->GetIsolate();
    if (!host)
        return 0;

    if (context.IsEmpty())
        context = iso->GetCurrentContext();

    v8::Context::Scope context_scope(context);
    v8::HandleScope scope(iso);

    // create interface object
    $ns suffix="::"$js::$name$_js_dispatcher* difc = new $ns suffix="::"$js::$name$_js_dispatcher(host);

    difc->_object.Reset(iso, difc->create_interface_object(context));
    return difc;
}

$-(/if)$
////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_$name$(bool on)
{
    //script interface wrapper from data interface
    interface_register::register_interface_creator("$name$@dcwrapper.js", on ? (void*)&wrap_ifc_to_js_$name$ : nullptr, nullptr);

    //script interface maker from data host
    interface_register::register_interface_creator("$name$@dcmaker.js", on ? (void*)&make_js_ifc_from_host_$name$ : nullptr, nullptr);
}

//auto-register the bind function
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&register_binders_for_$name$);


void* force_register_$name$() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_$name$);
    return autoregger.get();
}

} //namespace js
$-[ns]$
} //namespace $@value$
$-[/ns]$

$-[/iface_data]$$[/class]$


//@file $name$ lua interface dispatcher generated by intergen v$version$
//See LICENSE file for copyright and license information

$-[class]$$[iface]$
#include "$relpathlua$"
$-[/iface]$
$-[iface_data]$
#include "$relpath$"
$-[/iface_data]$$[/class]$
#include "$hdr$"
$-[pastedefers]$

$@value$
$-[/pastedefers]$

#include <comm/intergen/ifc.lua.h>
#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_lua_capi.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

using namespace coid;
$-[class]$$[iface rest="\n\n"]$

////////////////////////////////////////////////////////////////////////////////
//
// lua handler of interface $name$ of class $..class$
//
////////////////////////////////////////////////////////////////////////////////
$-[ns]$
namespace $@value$ {
$-[/ns]$
namespace lua {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$_lua_dispatcher
    : public ::lua::interface_wrapper_base<$ns rest="::"$::$name$>
{
$-(if ?event)$
    mutable iref<::lua::weak_registry_handle> _events[$event.@size$];
    mutable bool _bound_events;

    void init_event_registry() {
        for (int i = 0; i < $event.@size$; i++) {
            _events[i] = nullptr;
        }
    }

$-(/if)$
$-(if ?hasprops)$
    // !!! TODO !!! has props
$-(/if)$
protected:

    backend intergen_backend() const override { return backend::lua; }
    //static constexpr coid::token lua_interface_class_name() {  return "$name$"_T; };

    // Tests if table on the top of the stack contains field with this iterface calss
    //@param push_on_top - if the call table is found, it is pushed on the top of the stack
    //@return - true if this class table including namespace tables are contained in the table on the top of the stack
    static bool contains_interface_class_table_internal(lua_State* L, bool push_on_top);
    // Gets this class interface table from the table on the top of the stack and pushes it on the top
    //@note - you must be 100% sure the class interface table is contained by the table on the top of the stack!!!
    static void get_interface_class_table_internal(lua_State* L);
public:

    /// Creates script iterface object in the context of this dispatcher
    /// @param make_weak - created interface object will be weak
    /// @param script_class_or_bind_var - script class name or binding variable name (see note)
    /// @param is_bind_var - specifies if script_class_or_bind_var argument should be interpreted as bind variable name or script class name
    /// @note is_bind_var is false, created interface objects will inherited from the table with name "script_class"
    /// @note is_bind_var is true, created interface objects will use existing table variable with "bind_var" name
    /// @note if script_class_or_bind_var is empty and is_bind_var is false created interface object is creted from empty table
    iref<::lua::registry_handle> create_interface_object(const iref<::lua::registry_handle>& context, bool make_weak, const coid::token& script_class_or_bind_var, bool is_bind_var);
$-(if ?event)$
    void bind_events_internal(lua_State * L, bool clear) const;
    void bind_events(bool force, const coid::token& script_class_name) const;
$-(/if)$

    COIDNEWDELETE($name$_lua_dispatcher);

    $name$_lua_dispatcher() $-(if ?event)$ : _bound_events(false)$(/if)$
    {
$-(if ?event)$
        init_event_registry();
$(/if)-$
    }

    explicit $name$_lua_dispatcher(iref<::lua::registry_handle> context, $ns suffix="::"$$name$* orig) $(if ?event)$: _bound_events(false) $(/if)${
        _base.create(orig);
        _vtable = _base->vtable();

        set_context(context);

        _host = _base->host<policy_intrusive_base>();

$-(if ?event)$
        init_event_registry();
$(/if)-$
    }


    explicit $name$_lua_dispatcher(policy_intrusive_base* host) $ - (if ?event)$ : _bound_events(false)$(/ if)$
    {
        set_host(host, this, 0);
    }

    ~$name$_lua_dispatcher() {

    }

    bool intergen_bind_capture(coid::binstring* capture, uint instid) override
    {
        return _real()->intergen_bind_capture(capture, instid);
    }

    void intergen_capture_dispatch(uint mid, coid::binstring& bin) override
    {
        _real()->intergen_capture_dispatch(mid, bin);
    }

    // --- registrar ---
    static int register_interface_$name$(lua_State * L, bool push);
    static int register_implementation_$name$(lua_State * L, const coid::token& implementation_script_class_name);

    // --- creators ---

$-[method ?creator]$
$(if !comments.empty)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$_lua_dispatcher> $name$(lua_State * L, const ::lua::script_handle& scriptpath
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bind_variable_name, const coid::token& script_class_name, iref<::lua::registry_handle>*);

    $-(if !internal)$
    static int luacreator_$name$$@order$(lua_State * L, ::lua::interface_context* ifc);
    $-(/if)$
$-[/method]$

    static int luarebind_events_exc(lua_State * L);
    static int luarebind_events(lua_State * L);


    // --- method wrappers ---

$-[method !static !destroy !internal !operator]$
    static int lua_$name$$@order$_exc(lua_State * L);
    static int lua_$name$$@order$(lua_State * L);
    static bool can_use_ffi_$name$$@order$();
    static void get_ffi_inject_$name$$@order$(coid::token& header, coid::token& body);
    static $return.type$ lua_$name$$@order$_ffi(void * ifc_this $-[args]$, $type$ $name$$size$$[/ args]$);
$-[/method]$
$-(if !event.empty)$

    // --- interface events ---

$-[event]$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$) $-(if ?const)$ const$(/if)$ override;
$-[/event]$

    virtual bool is_bound(event m) override {
        //if (!_bound_events) {
        //    static ::lua::registry_handle empty_registry_handle;
        //    bind_events(false, iref<::lua::registry_handle>(&empty_registry_handle));
        //}

        //return !_events[int(m)];
        return true;
    }

virtual void force_bind_script_events() {
    //static ::lua::registry_handle empty_registry_handle;
    DASSERT(0);
    //bind_events(true, iref<::lua::registry_handle>(&empty_registry_handle));
    //bind_events(true, iref<::lua::registry_handle>(&empty_registry_handle));
}

private:
    bool is_event_bound(int id)
    {
        /*if (!_bound_events) {
            static ::lua::registry_handle empty_registry_handle;
            bind_events(false, iref<::lua::registry_handle>(&empty_registry_handle));
        }*/

        return  true;//_bound_events && _events[id];
    }

    //event wrappers for event invocation from lua
$-[event]$
    static int lua_evback_$name$$@order$(lua_State * L);
$-[/event]$
$-(/if)$
};

$-[method !static !destroy !internal !operator]$
////////////////////////////////////////////////////////////////////////////////
//
//  $return.type$ $..ns suffix="::"$$..name$::$name$($[args rest=","]$ $type$ $name$$[/args]$)
//
__declspec(noinline) int $..name$_lua_dispatcher::lua_$name$$@order$_exc(lua_State * L)
{
    bool exception_caught = false;

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    try {
         // the first argument must be valid "self" object
        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "$..name$.$name$";
            tmp << "!(Maybe you called the method with 'self.$name$' instead of 'self:$name$ !')";
            throw coid::exception(tmp);
        }

        const int args_count = lua_gettop(L) - 1;

        if (args_count < $ninargs_nondef$ || args_count > $ninargs$) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "$..name$.$name$";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        ::lua::interface_wrapper_base<$..ns rest = "::"$::$..name$>* ifc = reinterpret_cast<::lua::interface_wrapper_base<$..ns rest = "::"$::$..name$>*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        auto R_ = ifc ? ifc->_real() : 0;
        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "$..name$.$name$";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).set_context(ifc->_context.get());

        //stream the arguments in
$-[args ?inarg !nojs]$
  $-(if !iref)$
        static_assert(coid::has_metastream_operator<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$>::value, "missing metastream operator for '$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$'");
  $-(/if)$
$-[/args]$

$-[args ?inarg !nojs]$
        lua_pushvalue(L, $@order$ + 2);

  $-(if !defval.empty ?ptr)$
        threadcached<$basetype$> $name$__tmp;
        $basetype$* $name$ = &$name$__tmp;
        if ($@order$ < args_count)
            from_lua($name$__tmp);
        else
            $name$ = $defval$;
  $-(elif !defval.empty)$
        threadcached<$basetype$> $name$;
        if ($@order$ < args_count)
            from_lua($name$);
        else
            $name$ = $defval$;
  $-(elif)$
        threadcached<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$> $name$;
        from_lua($name$);
  $-(/if)$

        lua_pop(L, 1); // who pushes, must pop!
$-[/args]$

        //out params
$-[args ?outarg !inarg]$
        $basetype$ $name$;
$-[/args]$

        // invoke
        $(if !return.type="void")$$return.type$ rval__ = $(/if)$R_->$name$($[args rest=", "]$ $-(if ?ptr ?outarg)$&$-(elif ?ptr ?defval.empty !specptr)$&$(/if)$ $-(if ?nojs)$$defval$$(elif)$$name$$(/if)$$[/args]$);

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).set_context(ifc->_context.get());
$-(if ?nalloutargs)$

        //stream out
$-(if ?multiout)$
        lua_createtable(L, 0, $nalloutargs$);
$-(/if)$
$-(if !return.type="void")$
        to_lua(rval__); $-(if ?multiout)$ lua_setfield(L, -2, "_ret");$(/if)$
$-(/if)$
$-[args ?outarg]$
  $-(if ?..multiout)$
        to_lua($name$); lua_setfield(L, -2, "$name$");
  $-(elif)$        
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        to_lua($name$);
  $-(/if)$
$-[/args]$

$-(/if)-$

$-(if ?nalloutargs)$
        constexpr int num_results = 1;
$-(elif)$        
        constexpr int num_results = 0;
$-(/if)$  

#ifdef _DEBUG
    const int curr_stack_top = lua_gettop(L);
    DASSERT(curr_stack_top == stack_top + num_results);
#endif

        return num_results;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int $..name$_lua_dispatcher::lua_$name$$@order$(lua_State * L){
    int res = lua_$name$$@order$_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

bool $..name$_lua_dispatcher::can_use_ffi_$name$$@order$(){
    const MetaDesc * dsc = nullptr;

    return false;
}

void $..name$_lua_dispatcher::get_ffi_inject_$name$$@order$(coid::token& header, coid::token& body){
    static const coid::token h = "typedef $return.type$ (*$..name$_$name$$@order$_fun)(void * ifc_this $-[args]$, $type$ $name$$size$$[/args]$)\n";
    header = h;
    static const coid::token b =
"$..name$.$name$_ffi = ffi.cast(\"$..name$_$name$$@order$_fun\",$..name$.$name$);\n"\
"function $..name$:$name$($-[args after=","]$$name$$[/args]$)\n"\
"   return $..name$.$name$_ffi(self.__cthis $-[args]$, $name$$[/args]$)\n"\
"end;\n";
    body = b;
}
/*
$return.type$ $..name$_lua_dispatcher::lua_$name$$@order$_ffi(void * ifc_this $-[args]$, $type$ $name$$size$$[/args]$){

}
*/
$-[/method]$
$-[event]$
////////////////////////////////////////////////////////////////////////////////
$return.type$ $..name$_lua_dispatcher::$name$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$) $-(if ?const)$ const$(/if)$
{
$-(if ?internal)$
    throw coid::exception("method not marked for scripting");
$-(elif)$
    DASSERT(_bound_events);
    //bind_events(false, ::lua::registry_handle::get_empty());
    lua_State * L = _context->get_state();
    iref<::lua::weak_registry_handle> ev__ = _events[$@order$];

    if (ev__->is_empty())
    $-(if ?default_event_body)$ {
        $default_event_body$;
        $-(if ?return.type="void")$
        return;
        $-(/if)$
    }
    $-(elif !noevbody)$
        return;
    $-(elif)$
        throw coid::exception("$name$ handler not implemented");
    $-(/if)$

    THREAD_SINGLETON(coid::lua_streamer_context).set_context(_context.get());

// check if metastream operator exists for non iref args
$-[args ?inarg !iref]$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
$ - [/ args]$

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_pushcfunction(L, &::lua::catch_lua_error); // push pcall error handler
// stream in args and lua function for event call
    ev__->push_ref();
    _object->push_ref();

    DASSERT(lua_isfunction(L, -2)); // check if event is valid
    DASSERT(lua_istable(L, -1)); // check if self param

$-(if ?ninargs)$
$-[args ?inarg]$
  $-(if ?iref)$
    if (!$name$.is_empty()) {
        iref<::lua::registry_handle> $name$_handle = ::lua::wrap_interface($name$.get(), _context);
        if ($name$_handle.is_empty()) {
            lua_pushnil(L);
        }
        else {
            $name$_handle->push_ref();
        }
    }
    else {
        lua_pushnil(L);
    }
  $-(elif)$
    lua_streamer<$basetype$>::to_lua($name$); // TODO: volatile streamers
  $-(/if)$
$-[/args]$

$-(/if)$
$-(if ?return.type="void" !noutargs)$
    constexpr uint nres = 0;
$-(elif)$
    constexpr uint nres = 1;
$(/if)-$

// call event
    int res = lua_pcall(L,$ninargs$ + 1,nres,-3-$ninargs$);
$-[args ?inarg]$$(if ?volatile)$
    // TODO: some volatile cleanup was here
$(/if)$
$-[/args]$

    if (res != 0) {
        if (0)
        {
            ::lua::debug_print_stack(L);
        }

        lua_remove(L, -2); // pop pcall error handler
#ifdef _DEBUG
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == stack_top + 1); // +1 because error message is on the stack
#endif

        ::lua::throw_lua_error(L, "");
    }

// gather results
    THREAD_SINGLETON(coid::lua_streamer_context).set_context(_context.get());

$-(if !noutargs)$
  $-(if !return.type="void")$
    $-(if ?return.iref)$
    $return.type$ _rval_;
    $-(elif)$
    static_assert(coid::has_metastream_operator<$return.type$>::value, "missing metastream operator for '$return.type$'");
    threadcached<$return.type$> _rval_;
    $-(/if)$
    try{
        from_lua(_rval_);
        lua_pop(L, 1); // pop return value
    }
    catch (const coid::exception& e)
    {
        lua_pop(L, 2); // pop return value and pcall error handler;
        throw e;
    }
  $-(/if)$
$-(elif)$
  $-(if ?return.type="void" ?noutargs="1")$
    $-(if !return.iref)$
      $-[args ?outarg]$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
      $-[/args]$
    $-(/if)$
    try{
    $-[args ?outarg]$
    $-(if ?ptr)$
        if ($name$)
            from_lua(*$name$);
    $-(elif)$
        from_lua($name$);
    $-(/if)$
        lua_pop(L, 1); // pop return value
    }
    catch (const coid::exception& e)
    {
        lua_pop(L, 2); // out param value and pcall error handler;
        throw e;
    }
    $-[/args]$
  $-(elif)$
    if (!lua_istable(L,-1))
    {
        lua_pop(L, 2); // out param value and pcall error handler;
        throw ::lua::lua_event_exception("Multiple return values expected!");
    }

    $-(if !return.type="void")$
      $-(if ?return.iref)$
    $return.type$ _rval_;
      $-(elif)$
    static_assert(coid::has_metastream_operator<$return.type$>::value, "missing metastream operator for '$return.type$'");
    threadcached<$return.type$> _rval_;
      $-(/if)$
    try
    {
        if(!lua_hasfield(L, -1, "_ret")) {
            throw ::lua::lua_event_exception("Return value with name '_ret' not found in result table!");
        }
        lua_getfield(L, -1, "_ret");
        from_lua(_rval_);
        lua_pop(L, 1); // pop '_ret' field

    $-(elif)$
    try
    {
    $-(/if)$
    $-[args ?outarg !iref]$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
    $-[/args]$
    $-[args ?outarg rest="\n" first="\n"]$
        // get and set "$name$" out param value
        if(!lua_hasfield(L, -1, "$name$")) {
            throw ::lua::lua_event_exception("Return value with name ""$name$"" not found in result table!");
        }
        lua_getfield(L,-1,"$name$");
      $-(if ?ptr)$
        if ($name$)
        {
            from_lua(*$name$);
            lua_pop(L, 1); // pop '"$name$"' field
        }
      $-(elif)$
        from_lua($name$);
        lua_pop(L, 1); // pop '"$name$"' field
      $-(/if)$
    $-[/args]$
    }
    catch (const ::lua::lua_event_exception& e)
    {
        lua_pop(L, 2); // pop from_lua value, out param value and pcall error handler;
        throw e;
    }
    catch(const coid::exception& e)
    {
        lua_pop(L, 3); // pop out param value and pcall error handler;
        throw e;
    }

    lua_pop(L, 1); // pop result table
  $-(/if)$
$-(/if)$

    lua_pop(L, 1); // pop pcall error handler
#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top);
#endif

  $-(if !return.type="void")$
    return _rval_;
  $-(/if)$
$-(/if)$
}

$-[/event]$


////////////////////////////////////////////////////////////////////////////////
_declspec(noinline) int $name$_lua_dispatcher::luarebind_events_exc(lua_State * L)
{
$-(if ?event)$
    try {
        if (!lua_istable(L,-2) || !lua_hasfield(L, -2, ::lua::_lua_dispatcher_cptr_key))
            return 0;

        lua_getfield(L, -2, ::lua::_lua_dispatcher_cptr_key);
        if (!lua_isuserdata(L,-1))
            return 0;

        $ns suffix="::"$lua::$name$_lua_dispatcher* ifc = reinterpret_cast<$ns suffix="::"$lua::$name$_lua_dispatcher*>
            (*static_cast<size_t*>(lua_touserdata(L,-1)));

        lua_pop(L, 1); // pop user data

        // now only script object with events is on the top of the stack

        if (ifc) {
            if (ifc->intergen_real_interface() != ifc)
            {
                ifc->assign_safe(nullptr, nullptr);
                ifc->assign_safe(ifc, nullptr);
            }

            ifc->bind_events_internal(L, false);
         }
    }
    catch (coid::exception e) {
        lua_pushtoken(L, e.text());
        ::lua::catch_lua_error(L);
    }

    return 0;
$-(elif)$
    return 0;
$-(/if)$
}

int $name$_lua_dispatcher::luarebind_events(lua_State * L) {
    int res = luarebind_events_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

////////////////////////////////////////////////////////////////////////////////

bool $name$_lua_dispatcher::contains_interface_class_table_internal(lua_State * L, bool push_on_top)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    int num_pops = 0;
    constexpr int num_namespaces = $ns.@size$;
$-[ns]$
    if (num_pops == $@order$ && lua_hasfield(L, -1, "$@value$"))
    {
        lua_getfield(L, -1, "$@value$");
        num_pops++;
    }
$-[/ns]$

    bool result = (num_pops == num_namespaces) && lua_hasfield(L, -1, "$name$");

    if (push_on_top && result)
    {
        lua_getfield(L, -1, "$name$");
        lua_insert(L, -1 - num_namespaces);
    }

    lua_pop(L, num_pops);

    DASSERT((result&& push_on_top) ? (stack_top + 1 == lua_gettop(L)) : (stack_top == lua_gettop(L)));

    return result;
}

////////////////////////////////////////////////////////////////////////////////

void $name$_lua_dispatcher::get_interface_class_table_internal(lua_State* L)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    DASSERT(contains_interface_class_table_internal(L, false));

    constexpr int num_namespaces = $ns.@size$;
$-[ns rest="\n"]$
    lua_getfield(L, -1, "$@value$");
$-[/ns]$

    lua_getfield(L, -1, "$name$");
    lua_insert(L, -1 - num_namespaces);
    lua_pop(L, num_namespaces);

    DASSERT(stack_top + 1 == lua_gettop(L));
}

////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> $name$_lua_dispatcher::create_interface_object(const iref<::lua::registry_handle>& context, bool make_weak, const coid::token& script_class_or_bind_var, bool is_bind_var)
{
    lua_State * L = context->get_state();

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    context->push_ref();

    if(!is_bind_var)
    {
        // get object table
        lua_createtable(L, 0, 3);
    }
    else
    {
        if (!lua_hasfield(L, -1, script_class_or_bind_var))
        {
            lua_pop(L, 1); // pop context table
            coid::exception e("");
            e << "Given context doesn't contain object binding variable with name " << script_class_or_bind_var << "!";
            throw e;
        }

        // get object table
        lua_getfield(L, -1, script_class_or_bind_var);
    }

    // get metatable
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_dispatcher_cptr_key);

    cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this->intergen_real_interface());
    lua_setfield(L, -2, ::lua::_lua_interface_cptr_key);

    lua_pushnumber(L, ints($hash$));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);


    if (0)
    {
        ::lua::debug_print_stack(L);
    }

    // set index table
    if (!is_bind_var && !script_class_or_bind_var.is_empty())
    {
        if (!lua_hasfield(L, -2, script_class_or_bind_var))
        {
            lua_pop(L, 2); // pop context and object table
            coid::exception e("");
            e << "Given contetx doesn't contain script class with name " << script_class_or_bind_var << "!";
            throw e;
        }

        lua_getfield(L, -2, script_class_or_bind_var);
    }
    else
    {
        // first check context if the class is registered (implemented) there
        lua_pushvalue(L, -2); // push context table to to top
        if (!contains_interface_class_table_internal(L, true)) 
        {
            // check the interface metatable register if the class is registered there and register it if necessary
            lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
            if (!contains_interface_class_table_internal(L, true))
            {
                register_interface_$name$(L, true);
            }

            lua_remove(L, -2); // remove interface metatable register table
        }
        lua_remove(L, -2); // remove the context table
    }
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);

    iref<::lua::registry_handle> obj;

    if (make_weak) {
        obj = new ::lua::weak_registry_handle(L);
        lua_getfield(L, -1, ::lua::_lua_dispatcher_cptr_key);
        lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_WEAK_IFC_METATABLE_INDEX);
        lua_setmetatable(L,-2);
        lua_pop(L, 1);
        add_refcount();
    }
    else {
        obj = new ::lua::registry_handle(L);
    }

    obj->set_ref();

    lua_pop(L, 1); // pop context table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(stack_top == current_stack_top);
    }
#endif

    _object = obj;
    set_context(context);
    return obj;
}


$-(if !event.empty)$

void $name$_lua_dispatcher::bind_events_internal(lua_State * L,  bool clear) const
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif
    static token names[] = {
$-[event]$
        "$name$",
$-[/event]$
    };

    for (int i = 0; i<$event.@size$; ++i)
        {
            _events[i].create(new ::lua::weak_registry_handle(L));

            if (clear) {
                continue;
            }
            lua_getfield(L, -1, names[i]);
            if (!lua_isfunction(L, -1)) {
                lua_pop(L, 1);
                continue;
            }

            _events[i]->set_ref();
        }

        _bound_events = true;

#ifdef _DEBUG
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == stack_top);
#endif
}

////////////////////////////////////////////////////////////////////////////////
void $name$_lua_dispatcher::bind_events(bool force, const coid::token& script_class_name) const
{
    if (!force && _bound_events)
        return;

    lua_State * L = _context->get_state();
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif
    _object->push_ref();  // push interface object table
    _context->push_ref(); // push context table

    if (script_class_name.is_empty())
    {
        if (!contains_interface_class_table_internal(L, true))
        {
            lua_pop(L, 2); // pop interface object and context table
            coid::exception e("");
            e << "Script doesn't implements this class '" << "$ns rest ="." after ="."$$name$" << "'!";
            throw e;

        }
    }
    else
    {
        if (!lua_hasfield(L, -1, script_class_name)) {
            lua_pop(L, 2); // pop interface object and context table
            coid::exception e("Script doesn't implements this class '");
            e << script_class_name << "'!";
            throw e;
        }

        lua_getfield(L, -1, script_class_name); // push script class table on the top of the stack
    }

    bind_events_internal(L, false);

    lua_pop(L, 3); // interface object, context and script class table

#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top);
#endif
}

$-(/if)$

// --- registrar ---
int $name$_lua_dispatcher::register_interface_$name$(lua_State * L, bool push) {
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_rawgeti(L,LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
$-[ns]$

    lua_createtable(L, 0, 0); // table for namespace $@value$
    lua_pushvalue(L, -1);
    lua_setfield(L, -3, "$@value$");
    lua_remove(L, -2); // remove parent table from a stack
$-[/ns]$

    lua_createtable(L, 0, 0);

$-[method !static !destroy !internal !operator]$
    lua_pushcfunction(L, &$..name$_lua_dispatcher::lua_$name$$@order$);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "$name$");

$-[/method]$
$-(if ?event)$
    lua_pushcfunction(L, &$name$_lua_dispatcher::luarebind_events);
    lua_setfield(L, -2, ::lua::_lua_rebind_events_key);

$-(/if)$
    if (push)
    {
        lua_pushvalue(L, -1);
        lua_insert(L, -3);
    }

    lua_setfield(L, -2, "$name$");
    lua_pop(L, 1); // pop namespace or interface metatable register table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == (push ? stack_top + 1 : stack_top)); // ensure we left the stack in the initial state
    }
#endif

    return 0;
}

int $name$_lua_dispatcher::register_implementation_$name$(lua_State * L, const coid::token& implementation_script_class_name)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_pushvalue(L, LUA_ENVIRONINDEX); // push script context
    DASSERT(::lua::is_context_table(L, -1));

$-(if !ns.empty)$
    if(implementation_script_class_name.is_empty())
    {
$-[ns rest = "\n"]$
        lua_createtable(L, 0, 0); // table for namespace $@value$
        lua_pushvalue(L, -1);
        lua_setfield(L, -3, "$@value$");
        lua_remove(L, -2); // remove parent table from a stack
$-[/ns]$
    }
$-(/if)$

    lua_createtable(L, 0, 0); // table for class
    lua_pushvalue(L, -1); // get metatable
    lua_setmetatable(L, -2); // it is its own metatable

    // new we set __index table to aquire methods for c interface
    lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
    if (!contains_interface_class_table_internal(L, true))
    {
        register_interface_$name$(L, true);
    }

    lua_remove(L, -2); // remove interface metatable register table
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);

$-[event]$
    lua_pushtoken(L,"empty_event");
    lua_setfield(L, -2, "$name$");
$[/event]-$

    lua_setfield(L, -2, implementation_script_class_name.is_empty()? "$name$" : implementation_script_class_name);
    lua_pop(L, 1); // pop namespace or script context table

#ifdef _DEBUG
    DASSERT(lua_gettop(L) == stack_top); // ensure we left the stack in the initial state
#endif

    return 0;
}


// --- creators ---

$-[method ?creator]$
////////////////////////////////////////////////////////////////////////////////
iref<$..name$_lua_dispatcher> $..name$_lua_dispatcher::$name$(lua_State * L, const ::lua::script_handle& script
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bind_variable_name, const coid::token& script_class_name, iref<::lua::registry_handle>* ctx)
{

    // create interface object
    iref<$..name$_lua_dispatcher> ifc = $..ns suffix="::"$$..name$::$name$(new $..name$_lua_dispatcher$[args]$, $name$$[/args]$);
    if (!ifc)
        throw coid::exception() << "failed to create interface object";

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    try
    {
        iref<::lua::registry_handle> context = script.load_script(L);

        if (ctx)
            *ctx = context;

        ifc->set_context(context);

        const bool is_bind_var = !bind_variable_name.is_empty();
        ifc->_object = ifc->create_interface_object(context, false, is_bind_var ? bind_variable_name : script_class_name, is_bind_var);

$-(if ?..event)$
        ifc->bind_events(false, script_class_name);
$-(/if)$
    }
    catch (coid::exception& e)
    {
        throw e;
    }

#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top);
#endif
    return ifc;
}

$-(if !internal)$
////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from LUA
///
///  iref<$..ns suffix="::"$$..name$> $..ns suffix="::"$$..name$::$name$($[args rest=","]$ $type$ $name$$[/args]$)
///

int $..name$_lua_dispatcher::luacreator_$name$$@order$(lua_State * L, ::lua::interface_context* ifc)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    const int args_count = lua_gettop(L);

    if (args_count < $ninargs_nondef$ || args_count > $ninargs$) { //in/inout arguments
        coid::charstr tmp = "Wrong number of arguments in ";
        tmp << "$..name$.$name$";
        throw coid::exception(tmp);
    }

    iref<::lua::registry_handle> context = nullptr;
    if (ifc != nullptr)
    {
        context = ifc->_context;
    }
    else
    {
        context.create(new ::lua::weak_registry_handle(L));
        lua_pushvalue(L, LUA_ENVIRONINDEX);
        DASSERT(::lua::is_context_table(L, -1));
        context->set_ref();
    }

    //stream the arguments in
    THREAD_SINGLETON(coid::lua_streamer_context).set_context(context.get());

$-[args ?inarg !nojs]$
    lua_pushvalue(L, $@order$ + 1);
    $-(if ?iref)$
        $basetype$ $name$;
        $-(if !defval.empty)$
    if ($@order$ < args_count)
        from_lua($name$);
    else
        $name$ = $defval$;
        $-(elif)$
    from_lua($name$);
        $-(/if)$
    $-(elif)$
    static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator '$basetype$'");
        $-(if !defval.empty ?ptr)$
    threadcached<$basetype$> $name$__tmp;
    $basetype$ *$name$ = &$name$__tmp;
    if ($@order$ < args_count)
        from_lua($name$__tmp);
    else
        $name$ = $defval$;
        $-(elif !defval.empty)$
    threadcached<$basetype$> $name$;
    if ($@order$ < args_count)
        from_lua($name$);
    else
        $name$ = $defval$;
        $-(elif)$
    threadcached<$basetype$> $name$;
    from_lua($name$);
        $-(/if)$
    $-(/if)$
    lua_pop(L, 1); // who pushes, must pop!
$[/args]-$

//out params
$-[args ?outarg !inarg]$
    $basetype$ $name$;
$[/args]-$

    iref<$..name$_lua_dispatcher> nifc = $..ns suffix="::"$$..name$::$name$(new $..name$_lua_dispatcher$[args]$, $(if ?ptr ?outarg)$&$(elif ?ptr ?defval.empty !specptr)$&$(/if)$$name$$[/args]$);

    //stream out
$-(if ?noutargs)$
    lua_createtable(L, 0, $noutargs$ + 1);
    if (nifc) {
        nifc->set_context(context);
        nifc->create_interface_object(nifc->_context, true, "" , false)->push_ref();
    }
    else {
        lua_pushnil(L);
    }

    lua_setfield(L, -2, "ret");

    $-[args ?outarg]$
        $-(if !iref)$
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        $-(/if)$
        to_lua($name$);
        lua_setfield(L, -2, "$name$");
    $[/args]-$
$-(elif)$
    if (nifc) 
    {
        nifc->set_context(context);
        nifc->create_interface_object(context, true, "", false)->push_ref();
    }
    else {
        lua_pushnil(L);
    }
$-(/if)$

#ifdef _DEBUG
    const int current_stack_top = lua_gettop(L);
    DASSERT(current_stack_top == stack_top + 1); // starting top + number of results
#endif

    return 1;
}

$-(/ if)$
$-[/ method]$
$-(if !virtual)$
////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref <::lua::registry_handle> create_wrapper_$name$(::$ns rest = "::" after = "::"$$name$* orig, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!orig) return nullptr;

    iref<$ns suffix="::"$lua::$name$_lua_dispatcher> ifc;
    iref <::lua::registry_handle> obj;

    if (orig->intergen_backend() == intergen_interface::backend::lua)
        obj = static_cast<$name$_lua_dispatcher*>(orig)->_object;

    if (obj.is_empty()) {
        // create interface object
        ifc.create(new $ns suffix="::"$lua::$name$_lua_dispatcher(context, static_cast<::$ns suffix="::"$$name$*>(orig)));

        obj = ifc->create_interface_object(context, true, "", false);
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA interface from a host
static iref<$ns rest = "::" after = "::"$lua::$name$_lua_dispatcher> create_maker_$name$(policy_intrusive_base* host, iref<::lua::registry_handle> context)
{
    // check that the orig points to an object
    if (!host)
        return 0;

    // create interface object
    iref<$ns rest = "::" after = "::"$lua::$name$_lua_dispatcher> ifc;

    ifc.create(new $ns rest = "::" after = "::"$lua::$name$_lua_dispatcher(host));
    ifc->create_interface_object(context, false, "", false);
$-(if ?event)$
    ifc->bind_events(false, "");
$-(/if)$

    return ifc;
}

$-(/if)$
////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_$name$(bool on)
{
    // implement in context function
    interface_register::register_interface_creator("lua::implement_class.$ns rest="." after="."$$name$", on ? (void*)&$name$_lua_dispatcher::register_implementation_$name$ : nullptr, nullptr);

$-[method ?creator]$
    //c++ creator of Lua interface object
    interface_register::register_interface_creator("$..ns suffix="::"$$..name$.$name$@creator.lua", on ? (void*)&$..name$_lua_dispatcher::$name$ : nullptr, nullptr);
$-(if !internal)$

    //creator from script
    interface_register::register_interface_creator("lua.$..ns rest="." after="."$$..name$.$name$", on ? (void*)&$..name$_lua_dispatcher::luacreator_$name$$@order$ : nullptr, nullptr);
$-(/if)$
$-[/method]$
$-(if !virtual)$

    //wrapper interface creator from existing c++ interface
    interface_register::register_interface_creator("$ns suffix="::"$$name$@wrapper.lua", on ? (void*)&create_wrapper_$name$ : nullptr, nullptr);

    //js interface creator from host
    interface_register::register_interface_creator("$ns suffix="::"$$name$@maker.lua", on ? (void*)&create_maker_$name$ : nullptr, nullptr);
$-(/if)$
}

//auto-register the bind function
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&register_binders_for_$name$);

void* force_register_$name$() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_$name$);
    return autoregger.get();
}

} //namespace lua
$-[ns]$
} //namespace $@value$
$-[/ns]$

$-[/iface]$
$[iface_data rest="\n\n"]$
////////////////////////////////////////////////////////////////////////////////
//
// lua handler of data interface $name$ of class $..nsx$$..class$
//
////////////////////////////////////////////////////////////////////////////////
$[ns]$
namespace $@value$ {
$-[/ns]$
namespace lua {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$_lua_dispatcher
    : public ::lua::interface_context
{
public:

    iref<::lua::registry_handle> create_interface_object(const iref<::lua::registry_handle>& context);

    COIDNEWDELETE($name$_lua_dispatcher);

    explicit $name$_lua_dispatcher(::$..nsx$$..class$* host)
    {
        ifc = coref<$name$>::from_host(host);
    }

    explicit $name$_lua_dispatcher(const coref<$name$>& ifc) : ifc(ifc)
    {}

    ~$name$_lua_dispatcher()
    {}

    // --- creators ---

$-[method ?creator]$
$(if !comments.empty)$$[comments]-$
    $@value$
$[/comments]$$(/if)-$
    static iref<$..name$_lua_dispatcher> $name$(const ::lua::script_handle& scriptpath
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname);

    $-(if !internal)$
        static int luacreator_$name$$@order$(lua_State * L, ::lua::interface_context* ifc);

    $-(/if)$
$-[/method]$
    // --- method wrappers ---

$-[method !static !destroy !internal !operator]$
    static int lua_$name$$@order$_exc(lua_State * L);
    static int lua_$name$$@order$(lua_State* L);
$-[/method]$

protected:
        // Tests if table on the top of the stack contains field with this iterface calss
    //@param push_on_top - if the call table is found, it is pushed on the top of the stack
    //@return - true if this class table including namespace tables are contained in the table on the top of the stack
    static bool contains_interface_class_table_internal(lua_State* L, bool push_on_top);

    static int register_interface_$name$(lua_State * L, bool push);

private:


    coref<$name$> ifc;
};

////////////////////////////////////////////////////////////////////////////////

bool $name$_lua_dispatcher::contains_interface_class_table_internal(lua_State * L, bool push_on_top)
{
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    int num_pops = 0;
    constexpr int num_namespaces = $ns.@size$;
$-[ns]$
    if (num_pops == $@order$ && lua_hasfield(L, -1, "$@value$"))
    {
        lua_getfield(L, -1, "$@value$");
        num_pops++;
    }
$-[/ns]$

    bool result = (num_pops == num_namespaces) && lua_hasfield(L, -1, "$name$");

    if (push_on_top && result)
    {
        lua_getfield(L, -1, "$name$");
        lua_insert(L, -1 - num_namespaces);
    }

    lua_pop(L, num_pops);

    DASSERT((result&& push_on_top) ? (stack_top + 1 == lua_gettop(L)) : (stack_top == lua_gettop(L)));

    return result;
}

$-[method !static !destroy !internal !operator]$
////////////////////////////////////////////////////////////////////////////////
//
//  $return.type$ $..ns suffix="::"$$..name$::$name$($[args rest=","]$ $type$ $name$$[/args]$)
//
__declspec(noinline) int $..name$_lua_dispatcher::lua_$name$$@order$_exc(lua_State * L)
{
    bool exception_caught = false;
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    try {

        // the first argument must be valid "self" object
        if (!lua_istable(L, 1) || !lua_hasfield(L, 1, ::lua::_lua_dispatcher_cptr_key)) {
            coid::charstr tmp = "Caller is not valid object in ";
            tmp << "$..name$.$name$";
            tmp << "!(Maybe you called the method with 'self.$name$' instead of 'self:$name$ !')";
            throw coid::exception(tmp);
        }

        const int args_count = lua_gettop(L) - 1;

        if (args_count < $ninargs_nondef$ || args_count > $ninargs$) { //in/inout arguments
            coid::charstr tmp = "Wrong number of arguments in ";
            tmp << "$..name$.$name$";
            throw coid::exception(tmp);
        }

        lua_getfield(L, 1, ::lua::_lua_dispatcher_cptr_key);

        $..name$_lua_dispatcher* dispatcher = reinterpret_cast<$..name$_lua_dispatcher*>(
        *static_cast<size_t*>(lua_touserdata(L, -1)));
        lua_pop(L, 1);

        ::$....nsx$$....class$* R_ = reinterpret_cast<::$....nsx$$....class$*>(dispatcher->ifc.ready());

        if (!R_) {
            coid::charstr tmp = "Null interface object in ";
            tmp << "$..name$.$name$";
            throw coid::exception(tmp);
        }

        THREAD_SINGLETON(coid::lua_streamer_context).set_context(dispatcher->_context.get());

        //stream the arguments in
$-[args ?inarg !nojs]$
  $-(if !iref)$
        static_assert(coid::has_metastream_operator<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$>::value, "missing metastream operator for '$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$'");
  $-(/if)$
$-[/args]$

$-[args ?inarg !nojs]$
        lua_pushvalue(L, $@order$ + 2);

  $-(if !defval.empty ?ptr)$
        threadcached<$basetype$> $name$__tmp;
        $basetype$* $name$ = &$name$__tmp;
        if ($@order$ < args_count)
            from_lua($name$__tmp);
        else
            $name$ = $defval$;
  $-(elif !defval.empty)$
        threadcached<$basetype$> $name$;
        if ($@order$ < args_count)
            from_lua($name$);
        else
            $name$ = $defval$;
  $-(elif)$
        threadcached<$(if ?fnarg)$$type$ (*)($fnargs$)$(elif)$$basetype$$(/if)$> $name$;
        from_lua($name$);
  $-(/if)$

        lua_pop(L, 1); // who pushes, must pop!
$-[/args]$

        //out params
$-[args ?outarg !inarg]$
        $basetype$ $name$;
$-[/args]$

        //invoke
        $(if !return.type="void")$$return.type$ rval__ = $(/if)$R_->$intname$($[args rest=", "]$ $-(if ?ptr ?outarg)$&$-(elif ?ptr ?defval.empty !specptr)$&$(/if)$ $-(if ?nojs)$$defval$$(elif)$$name$$(/if)$$[/args]$);

        //stream out
        THREAD_SINGLETON(coid::lua_streamer_context).set_context(dispatcher->_context.get());
$-(if ?nalloutargs)$

        //stream out
$-(if ?multiout)$
        lua_createtable(L, 0, $nalloutargs$);
$-(/if)$
$-(if !return.type="void")$
        to_lua(rval__); $-(if ?multiout)$ lua_setfield(L, -2, "_ret");$(/if)$
$-(/if)$
$-[args ?outarg]$
  $-(if ?..multiout)$
        to_lua($name$); lua_setfield(L, -2, "$name$");
  $-(elif)$        
        static_assert(coid::has_metastream_operator<$basetype$>::value, "missing metastream operator for '$basetype$'");
        to_lua($name$);
  $-(/if)$
$-[/args]$

$-(/if)-$

$-(if ?nalloutargs)$
        constexpr int num_results = 1;
$-(elif)$        
        constexpr int num_results = 0;
$-(/if)$  

#ifdef _DEBUG
        const int curr_stack_top = lua_gettop(L);
        DASSERT(curr_stack_top == stack_top + num_results);
#endif
    
        return num_results;
    }
    catch (const coid::exception& e) {
        exception_caught = true;
        ::lua::process_exception_and_push_error_string_internal(e, L);
    }

    if (exception_caught) {
        lua_error(L);
    }

    return -1;
}

int $..name$_lua_dispatcher::lua_$name$$@order$(lua_State * L){
    int res = lua_$name$$@order$_exc(L);
    if (res == -1) {
        lua_error(L);
    }

    return res;
}

$-[/method]$
////////////////////////////////////////////////////////////////////////////////
iref<::lua::registry_handle> $name$_lua_dispatcher::create_interface_object(const iref<::lua::registry_handle>& context)
{
   lua_State * L = context->get_state();

#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    context->push_ref();
    
    lua_createtable(L, 0, 3);
    // get metatable
    lua_pushvalue(L, -1);
    lua_setmetatable(L, -2);

    void * cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(this);
    lua_setfield(L, -2, ::lua::_lua_dispatcher_cptr_key);

    cptr_holder = lua_newuserdata(L, sizeof(size_t));
    *static_cast<size_t*>(cptr_holder) = reinterpret_cast<size_t>(nullptr); /// do we really need interface ptr?
    lua_setfield(L, -2, ::lua::_lua_interface_cptr_key);

    lua_pushnumber(L, ints($hash$));
    lua_setfield(L, -2, ::lua::_lua_class_hash_key);


    if (0)
    {
        ::lua::debug_print_stack(L);
    }

    // set index table
    lua_rawgeti(L, LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
    if (!contains_interface_class_table_internal(L, true))
    {
        register_interface_$name$(L, true);
    }

    lua_remove(L, -2); // remove interface metatable register table
 
    lua_setfield(L, -2, ::lua::_lua_parent_index_key);

    iref<::lua::registry_handle> obj;
    obj = new ::lua::registry_handle(L);
    obj->set_ref();

    lua_pop(L, 1); // pop context table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(stack_top == current_stack_top);
    }
#endif

    _object = obj;
    set_context(context);
    return obj;
}

$-(if !virtual)$
////////////////////////////////////////////////////////////////////////////////
///Create LUA wrapper from an existing interface object
iref<::lua::registry_handle> wrap_ifc_to_lua_$name$(const coref<$name$>& orig_ifc, const iref<::lua::registry_handle>& context)
{
    DASSERT_RET(context.is_set(), nullptr);

    // check that the orig points to an object
    if (!orig_ifc)
    {
        return nullptr;
    }
    
    // create interface object
    $ns suffix="::"$lua::$name$_lua_dispatcher* difc = new $ns suffix="::"$lua::$name$_lua_dispatcher(orig_ifc);

    return difc->create_interface_object(context);
}

////////////////////////////////////////////////////////////////////////////////
///Create LUA interface from a host
static iref<$ns suffix="::"$lua::$name$_lua_dispatcher> make_lua_ifc_from_host_$name$(::$..nsx$$..class$* host, const iref<::lua::registry_handle>& context)
{
    // check that the orig points to an object
    if (!host)
        return 0;

    // create interface object
    $ns suffix="::"$lua::$name$_lua_dispatcher* difc = new $ns suffix="::"$lua::$name$_lua_dispatcher(host);

    difc->_object = difc->create_interface_object(context);
    return difc;
}

$-(/if)$

////////////////////////////////////////////////////////////////////////////////

int $name$_lua_dispatcher::register_interface_$name$(lua_State * L, bool push) {
#ifdef _DEBUG
    const int stack_top = lua_gettop(L);
#endif

    lua_rawgeti(L,LUA_REGISTRYINDEX, ::lua::LUA_INTERFACE_METATABLE_REGISTER_INDEX); // push interface metatable register table
$-[ns]$

    lua_createtable(L, 0, 0); // table for namespace $@value$
    lua_pushvalue(L, -1);
    lua_setfield(L, -3, "$@value$");
    lua_remove(L, -2); // remove parent table from a stack
$-[/ns]$

    lua_createtable(L, 0, 0);

$-[method !static !destroy !internal !operator]$
    lua_pushcfunction(L, &$..name$_lua_dispatcher::lua_$name$$@order$);
    lua_pushvalue(L, LUA_GLOBALSINDEX);
    lua_setfenv(L, -2);
    lua_setfield(L, -2, "$name$");

$-[/method]$
$-(if ?event)$
    lua_pushcfunction(L, &$name$_lua_dispatcher::luarebind_events);
    lua_setfield(L, -2, ::lua::_lua_rebind_events_key);

$-(/if)$
    if (push)
    {
        lua_pushvalue(L, -1);
        lua_insert(L, -3);
    }

    lua_setfield(L, -2, "$name$");
    lua_pop(L, 1); // pop namespace or interface metatable register table

#ifdef _DEBUG
    {
        const int current_stack_top = lua_gettop(L);
        DASSERT(current_stack_top == (push ? stack_top + 1 : stack_top)); // ensure we left the stack in the initial state
    }
#endif

    return 0;
}

////////////////////////////////////////////////////////////////////////////////
static void register_binders_for_$name$(bool on)
{
    //script interface wrapper from data interface
    interface_register::register_interface_creator("$ns suffix="::"$$name$@dcwrapper.lua", on ? (void*)&wrap_ifc_to_lua_$name$ : nullptr, nullptr);

    //script interface maker from data host
    interface_register::register_interface_creator("$ns suffix="::"$$name$@dcmaker.lua", on ? (void*)&make_lua_ifc_from_host_$name$ : nullptr, nullptr);
}

//auto-register the bind function
LOCAL_FILE_SINGLETON_DEF(ifc_autoregger) $name$_autoregger = new ifc_autoregger(&register_binders_for_$name$);


void* force_register_$name$() {
    LOCAL_FUNCTION_SINGLETON_DEF(ifc_autoregger) autoregger = new ifc_autoregger(&register_binders_for_$name$);
    return autoregger.get();
}

} //namespace lua
$-[ns]$
} //namespace $@value$
$-[/ns]$

$-[/iface_data]$$[/class]$
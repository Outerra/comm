#pragma once

#ifndef _INTERGEN_GENERATED__$name$_H_
#define _INTERGEN_GENERATED__$name$_H_

//@file Interface file for $name$ interface generated by intergen
//See LICENSE file for copyright and license information

//host class $classnsx suffix="::"$$class$
//source file $srcfile$
$-[fwds first="\n\n//begin auto forward declarations\n" after="\n//end auto forward declarations"]$
 $-(if nss)$namespace $nss rest="::"$ { class $name$; }
 $-(elif)$
$(if ?type="1")$class$(elif)$struct$(/if)$ $name$;
$-(/if)$
$-[/fwds]$

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>
$-(if ?base)$

#include "$baseclass$.h"
$(/if)$
$-[pasters]$

$@value$
$-[/pasters]$

$[classnsx after="    "]$namespace $@value$ {
$[/classnsx]-$
class $class$;
$-[classnsx first="\r\n"]$}$[/classnsx]$


$-[ns]$
namespace $@value$ {
$-[/ns]$

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty)$$[comments]$
$@value$
$-[/comments]$$(/if)$
class $name$
    : public $(if ?base)$$base$$(elif)$intergen_interface$(/if)$
{
public:
$-[pasteinners]$
$@value$
$-[/pasteinners]$
$-(if ?varname ?destroy.name.empty)$

    virtual ~$name$() {
        if (_cleaner)
            _cleaner(this, 0);
    }
$-(/if)$
$-(if ?event)$

    // --- host helpers to check presence of event handlers in scripts ---

    enum class event {
$-[event !static]$
        $intname$ = $@order$,
$-[/event]$
    };

    virtual bool is_bound(event m) { return true; }
$-(/if ?event)$

    // --- creators ---
$-[method ?creator]$

$-(if !comments.empty)$
$[comments]$
    $@value$
$-[/comments]$$(/if)$
$-(if singleton)$
    static const iref<$..name$>& $name$(
        $-[args rest=", "]$$type$ $name$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$) {
        LOCAL_SINGLETON_DEF(iref<$..name$>) ref = iref<$..name$>($name$<$..name$>(0$[args]$, $name$$[/args]$));
        return *ref;
    }

    template<class T>
    static const iref<T>& $name$(T* _subclass_$[args]$, $type$ $name$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$);
$-(elif)$
    static iref<$..name$> $name$(
        $-[args rest=", "]$$type$ $name$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$) {
        return $name$<$..name$>(0$[args]$, $name$$[/args]$);
    }

    template<class T>
    static iref<T> $name$(T* _subclass_$[args]$, $type$ $name$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$);
$-(/if)$
$-[/method]$

    // --- interface methods ---
$-[method !static !destroy]$
$-(if !comments.empty)$
$[comments]$
    $@value$
$-[/comments]$$(/if)$
    $(if ?..virtual)$virtual $(/if)$$return.type$ $name$($[args rest=", "]$$ifckwds after=" "$$type$ $(if ?fnarg)$($-memfnclass after="::"-$ *$name$)($fnargs$)$(elif)$$name$$(/if)$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$) $-(if ?const)$ const$(/if)$$(if ?..virtual)$ = 0$(/if)$;
$-[/method]$
$-(if !event.empty)$

protected:
    // --- interface events (callbacks from host to client) ---
    // ---       overload these to handle host events       ---
    friend class ::$classnsx suffix="::"$$class$;

$-[event !static]$
$-(if !comments.empty)$
$[comments]$
    $@value$
$-[/comments]$$(/if)$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $(if ?fnarg)$(*$name$)($fnargs$)$(elif)$$name$$(/if)$$size$ $-(if ?defval)$ = $defval$$(/if)$$[/args]$) $-(if ?const)$ const$(/if)$
    $-(if ?pure)$ = 0;$(elif ?default_event_body)$ { $default_event_body$ }$(elif ?return.type="void")$ {}$(elif)${ throw coid::exception(HANDLER_NOT_IMPLEMENTED_MESSAGE); }$(/if)$
$-[/event]$

    virtual void force_bind_script_events() {}

public:
$-(/if)$

    // --- internal helpers ---

    ///Interface revision hash
    static const int HASHID = $hash$u;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "$ns suffix="::"$$name$"_T;
        return _name;
    }

    int intergen_hash_id() const override { return HASHID; }

    bool iface_is_derived( int hash ) const override {
        return hash == HASHID $-(if ?base)$ || $base$::iface_is_derived(hash)$(/if)$;
    }

    const coid::tokenhash& intergen_interface_name() const override {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static(backend bck) {
$-(if ?default_creator.empty)$
        static constexpr coid::token _dc(""_T);
$-(elif)$
        static constexpr coid::token _dc("$ns suffix="::"$$name$.$default_creator$@$hash$"_T);
$-(/if)$
        static constexpr coid::token _djs("$ns suffix="::"$$name$@wrapper.js"_T);
        static constexpr coid::token _djsc("$ns suffix="::"$$name$@wrapper.jsc"_T);
        static constexpr coid::token _dlua("$ns suffix="::"$$name$@wrapper.lua"_T);
        static constexpr coid::token _dnone;

        switch(bck) {
        case backend::cxx: return _dc;
        case backend::js:  return _djs;
        case backend::jsc: return _djsc;
        case backend::lua: return _dlua;
        default: return _dnone;
        }
    }

$-(if ?varname)$
    /// @return cached active interface of given host class
    /// @note host side helper
    static iref<$name$> intergen_active_interface(::$classnsx suffix="::"$$class$* host);

$-(/if)$

#if _MSC_VER == 0 || _MSC_VER >= 1920
    template<enum backend B>
#else
    template<enum class backend B>
#endif
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( backend bck ) const override {
        switch(bck) {
        case backend::js:  return intergen_wrapper_cache<backend::js>();
        case backend::jsc: return intergen_wrapper_cache<backend::jsc>();
        case backend::lua: return intergen_wrapper_cache<backend::lua>();
        default: return 0;
        }
    }

    backend intergen_backend() const override { return backend::cxx; }

    const coid::token& intergen_default_creator( backend bck ) const override {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<$name$, C>::value, "not a base class");

        typedef intergen_interface* (*fn_client)();
        fn_client cc = []() -> intergen_interface* {
            //also init profiler backend for clients from a different module
            profiler::init_backend_in_module();
            return new C;
        };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "$ns suffix="::"$$name$"_T;
        tmp << "@client-$hash$"_T << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc, nullptr);

        return 0;
    }

    $-(if !destroy.name.empty)$

    ~$name$() {
        VT_CALL($destroy.return.type$,($[destroy.args rest=","]$$type$$[/destroy.args]$),0)($[destroy.args rest=","]$$name$$[/destroy.args]$);
    $-(if ?varname)$
        if (_cleaner)
            _cleaner(this, 0);
    $-(/if)$
    }
    $-(/if)$
protected:
$-(if ?varname)$

    static coid::comm_mutex& share_lock() {
        static coid::comm_mutex _mx(500, false);
        return _mx;
    }

    ///Cleanup routine called from ~$name$()
    static void _cleaner_callback($name$* m, intergen_interface* ifc) {
        m->assign_safe(ifc, 0);
    }

    bool assign_safe(intergen_interface* client__, iref<$name$>* pout);

    typedef void (*cleanup_fn)($name$*, intergen_interface*);
    cleanup_fn _cleaner = 0;
$-(/if)$

    bool set_host(coid::ref_intrusive_base*, intergen_interface*, iref<$name$>* pout);
};
$-[pasteafters]$

$@value$
$-[/pasteafters]$

$-[method ?creator]$
////////////////////////////////////////////////////////////////////////////////
template<class T>
inline $(if singleton)$const iref<T>&$(elif)$iref<T>$(/if)$ $..name$::$name$(T* _subclass_
    $-[args]$, $type$ $name$$size$$[/args]$)
{
$-(if singleton)$
    LOCAL_SINGLETON_DEF(iref<T>) ref;
    if (*ref) return *ref;

$-(/if)$
    typedef iref<T> (*fn_creator)($..name$*$[args]$, $type$$[/args]$);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "$..ns suffix="::"$$..name$.$name$@$..hash$"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("$..name$"_T, "$..ns suffix="::"$$..name$.$name$"_T, "@$..hash$"_T);
        return $(if singleton)$*ref$(elif)$0$(/if)$;
    }

$-(if singleton)$
    *ref = create(_subclass_$[args]$, $name$$[/args]$);
    return *ref;
$-(elif)$
    return create(_subclass_$[args]$, $name$$[/args]$);
$-(/if)$
}

$-[/method]$

$-[method !static !destroy !virtual]$
$-(if ?return.ifc_type="none")$
inline auto $..name$::$name$($[args rest=", "]$$ifckwds after=" "$$type$ $(if ?fnarg)$($-memfnclass after="::"-$ *$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if ?const)$ const$(/if)$ -> $return.type$ { return $(if !return.ref !return.type="void")$std::move($(/if)-$ VT_CALL($return.type$,($[args rest=","]$ $-(if ?fnarg)$$type$($memfnclass after="::"$*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$) $-(if ?const)$ const$(/if)$,$index$)($[args rest=","]$ $-(if ?xref)$std::forward<$basetype$>($(/if)-$ $name$ $-(if ?xref)$)$(/if)-$ $[/args]$) $-(if !return.ref !return.type="void")$)$(/if)$; }
$-(elif)$
inline auto $..name$::$name$($[args rest=", "]$$ifckwds after=" "$$type$ $(if ?fnarg)$($-memfnclass after="::"-$ *$name$)($fnargs$)$(elif)$$name$$(/if)$$size$$[/args]$) $-(if ?const)$ const$(/if)$ -> $return.type$ { return ((*this).*(reinterpret_cast<$return.type$(coid::ref_intrusive_base::*)($[args rest=","]$ $-(if ?fnarg)$$type$($memfnclass after="::"$*)($fnargs$)$(elif)$$type$$(/if)-$ $size$$[/args]$) $-(if ?const)$ const$(/if)$>(_vtable[$index$])))($[args rest=","]$ $-(if ?xref)$std::forward<$basetype$>($(/if)-$ $name$ $-(if ?xref)$)$(/if)-$ $[/args]$); }
$-(/if)$
$-[/method]$

$-[ns]$
} //namespace
$-[/ns]$

#endif //_INTERGEN_GENERATED__$name$_H_

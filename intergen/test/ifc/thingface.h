#pragma once

#ifndef _INTERGEN_GENERATED__thingface_H_
#define _INTERGEN_GENERATED__thingface_H_

//@file Interface file for thingface interface generated by intergen
//See LICENSE file for copyright and license information

//host class n1::n2::thing

//begin auto forward declarations
namespace ifc1::ifc2 { class emptyface; }
struct component_ifc;
//end auto forward declarations

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#include "basething.h"


struct test;

namespace bt {
    struct base;
}

namespace n1 {
namespace n2 {
    class thing;
}}


namespace ifc1 {
namespace ifc2 {

////////////////////////////////////////////////////////////////////////////////
class thingface
    : public ifc::basething
{
public:

    // --- host helpers to check presence of event handlers in scripts ---

    enum class event {
        boo = 0,
        body = 1,
        strbody = 2,
    };

    virtual bool is_bound(event m) { return true; }

    // --- creators ---

    static iref<thingface> get() {
        return get<thingface>(0);
    }

    template<class T>
    static iref<T> get(T* _subclass_);

    // --- interface methods ---
    void xooo();

    /// @brief some method " test escaping
    /// @param a some argument " test escaping
    int hallo(int a, const coid::token& b, ifc_out coid::charstr& c);
    void noargs();
    ref<test> noscript();
    coid::charstr fallo(bool b, const char* str);
    void loo(bool a, int b);
    double operator()(const char* key) const;
    void operator()(const char* key, double value);
    void inout(ifc_inout test*& par);

    /// @brief return class interface
    iref<ifc1::ifc2::emptyface> ret_classifc();

    /// @brief return struct interface
    coref<component_ifc> ret_structifc();
    void nested(const coid::dynarray<bt::base>& stuff);

protected:
    // --- interface events (callbacks from host to client) ---
    // ---       overload these to handle host events       ---
    friend class ::n1::n2::thing;

    virtual void boo( const char* key, int some ) {}
    virtual const char* body() { return "string"; }
    virtual coid::charstr strbody() { return "value"; }

    virtual void force_bind_script_events() {}

public:

    // --- internal helpers ---

    ///Interface revision hash
    static const int HASHID = 2715180211u;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "ifc1::ifc2::thingface"_T;
        return _name;
    }

    int intergen_hash_id() const override { return HASHID; }

    bool iface_is_derived( int hash ) const override {
        return hash == HASHID || ifc::basething::iface_is_derived(hash);
    }

    const coid::tokenhash& intergen_interface_name() const override {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static(backend bck) {
        static constexpr coid::token _dc("ifc1::ifc2::thingface.get@2715180211"_T);
        static constexpr coid::token _djs("ifc1::ifc2::thingface@wrapper.js"_T);
        static constexpr coid::token _djsc("ifc1::ifc2::thingface@wrapper.jsc"_T);
        static constexpr coid::token _dlua("ifc1::ifc2::thingface@wrapper.lua"_T);
        static constexpr coid::token _dnone;

        switch(bck) {
        case backend::cxx: return _dc;
        case backend::js:  return _djs;
        case backend::jsc: return _djsc;
        case backend::lua: return _dlua;
        default: return _dnone;
        }
    }

    /// @return cached active interface of given host class
    /// @note host side helper
    static iref<thingface> intergen_active_interface(::n1::n2::thing* host);


#if _MSC_VER == 0 || _MSC_VER >= 1920
    template<enum backend B>
#else
    template<enum class backend B>
#endif
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( backend bck ) const override {
        switch(bck) {
        case backend::js:  return intergen_wrapper_cache<backend::js>();
        case backend::jsc: return intergen_wrapper_cache<backend::jsc>();
        case backend::lua: return intergen_wrapper_cache<backend::lua>();
        default: return 0;
        }
    }

    backend intergen_backend() const override { return backend::cxx; }

    const coid::token& intergen_default_creator( backend bck ) const override {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<thingface, C>::value, "not a base class");

        typedef intergen_interface* (*fn_client)();
        fn_client cc = []() -> intergen_interface* { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "ifc1::ifc2::thingface"_T;
        tmp << "@client-2715180211"_T << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc, nullptr);
        return 0;
    }

protected:

    static coid::comm_mutex& share_lock() {
        static coid::comm_mutex _mx(500, false);
        return _mx;
    }

    ///Cleanup routine called from ~thingface()
    static void _cleaner_callback(thingface* m, intergen_interface* ifc) {
        m->assign_safe(ifc, 0);
    }

    bool assign_safe(intergen_interface* client__, iref<thingface>* pout);

    typedef void (*cleanup_fn)(thingface*, intergen_interface*);
    cleanup_fn _cleaner = 0;

    bool set_host(policy_intrusive_base*, intergen_interface*, iref<thingface>* pout);

    ~thingface() {
        VT_CALL(void,(),0)();
        if (_cleaner)
            _cleaner(this, 0);
    }
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> thingface::get(T* _subclass_)
{
    typedef iref<T> (*fn_creator)(thingface*);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ifc1::ifc2::thingface.get@2715180211"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("thingface"_T, "ifc1::ifc2::thingface.get"_T, "@2715180211"_T);
        return 0;
    }

    return create(_subclass_);
}


inline auto thingface::xooo() -> void { return VT_CALL(void,(),0)(); }
inline auto thingface::hallo(int a, const coid::token& b, ifc_out coid::charstr& c) -> int { return VT_CALL(int,(int,const coid::token&,coid::charstr&),2)(a,b,c); }
inline auto thingface::noargs() -> void { return VT_CALL(void,(),3)(); }
inline auto thingface::noscript() -> ref<test> { return VT_CALL(ref<test>,(),4)(); }
inline auto thingface::fallo(bool b, const char* str) -> coid::charstr { return VT_CALL(coid::charstr,(bool,const char*),5)(b,str); }
inline auto thingface::loo(bool a, int b) -> void { return VT_CALL(void,(bool,int),6)(a,b); }
inline auto thingface::operator()(const char* key) const -> double { return VT_CALL(double,(const char*) const,7)(key); }
inline auto thingface::operator()(const char* key, double value) -> void { return VT_CALL(void,(const char*,double),8)(key,value); }
inline auto thingface::inout(ifc_inout test*& par) -> void { return VT_CALL(void,(test*&),9)(par); }
inline auto thingface::ret_classifc() -> iref<ifc1::ifc2::emptyface> { return ((*this).*(reinterpret_cast<iref<ifc1::ifc2::emptyface>(policy_intrusive_base::*)()>(_vtable[10])))(); }
inline auto thingface::ret_structifc() -> coref<component_ifc> { return ((*this).*(reinterpret_cast<coref<component_ifc>(policy_intrusive_base::*)()>(_vtable[11])))(); }
inline auto thingface::nested(const coid::dynarray<bt::base>& stuff) -> void { return VT_CALL(void,(const coid::dynarray<bt::base>&),12)(stuff); }

} //namespace
} //namespace

#endif //_INTERGEN_GENERATED__thingface_H_


//@file $name$ interface dispatcher generated by intergen

$-[class]$$[iface]$
#include "$relpath$"
$-[/iface]$$[/class]$
#include "$hdr$"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <type_traits>

using namespace coid;

$-[class iface.empty!]$
static_assert( std::is_base_of<policy_intrusive_base, $nss rest="::" after="::"$$class$>::value, "class '$class$' must be derived from coid::policy_intrusive_base");

$-[iface]$
////////////////////////////////////////////////////////////////////////////////
// interface $name$ of class $..class$
$[ns]$
namespace $@value$ {
$-[/ns]$

///
class $name$_dispatcher : public $name$
{
private:

    static ifn_t* get_vtable()
    {
        static ifn_t* vtable = 0;
        if(vtable) return vtable;

        vtable = new ifn_t[$nifcmethods$];
$-[method !static?]$
        vtable[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&$....ns$::$....class$::$intname$));
$-[/method]-$

        return vtable;
    }
$-(if varname?)$

    ///Cleanup routine called from ~$name$()
    static void _cleaner_callback( $name$* m, intergen_interface* ifc ) {
        policy_intrusive_base* host = static_cast<$name$_dispatcher*>(m)->_host.get();
        if(host) static_cast<$..ns default=" "$::$..class$*>(host)->$varname$ = ifc;
    }
$-(/if)$
    
public:

    // creator methods
    
$-[method static?]$
    static iref<$..name$> $name$( $..name$* __here__$[args]$, $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ )
    {
        iref<$....ns default=" "$::$....class$> host = $....ns$::$....class$::$intname$($[args rest=", "]$$name$$[/args]$);
        if(!host)
            return 0;

        $..name$_dispatcher* __disp__ = static_cast<$..name$_dispatcher*>(__here__);
        if(!__disp__)
            __disp__ = new $..name$_dispatcher;

        __disp__->_host.create(host.get());
        __disp__->_vtable = get_vtable();
        
        $--(if ..varname?)$
        if(!host->$..varname$) {
            __disp__->_cleaner = &_cleaner_callback;
            host->$..varname$ = __disp__;
        }
        $-(/if)$
        
        $-(if ..oncreateev?)$
        __disp__->$..oncreateev$();

        $-(/if)$
        $-(if ..oncreate?)$
        host->$..oncreate$();

        $-(/if)$
        return iref<$..name$>(__disp__);
    }

$-[/method]$
    ///Register interface creators to a global registry
    static void* register_interfaces()
    {
$-[method static?]$
        interface_register::register_interface_creator(
            "$..ns rest="::" after="::"$$..name$.$name$@$..hash$", (void*)&$name$);
$-[/method]$

        return (void*)&register_interfaces;
    }
};

//auto-register the available interface creators
static void* $name$_autoregger = $name$_dispatcher::register_interfaces();

void* force_register_$name$() {
    return $name$_dispatcher::register_interfaces();
}

$-[ns]$
} //namespace
$-[/ns]$

$-(if event?)$
// events

$[..nss]$namespace $@value$ {
$[/..nss]-$

$-[event !implicit?]$
$return.type$ $....class$::$intname$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$)
{
	if(!$..varname$) throw coid::exception("interface client not connected");
    return static_cast<$..ns rest="::" after="::"$$..name$&>(*$..varname$).$name$($[args rest=", "]$$name$$[/args]$);
}
$[/event]-$

$[..nss]$} //namespace
$[/..nss]-$
$(/if)-$

$-[/iface]$$[/class]$

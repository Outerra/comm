
//@file $name$ interface dispatcher generated by intergen

$-[class]$$[iface]$
#include "$relpath$"
$-[/iface]$$[/class]$
#include "$hdr$"

#include <comm/ref.h>
#include <comm/singleton.h>
#include <comm/binstring.h>
#include <type_traits>

using namespace coid;

$-[class iface.empty!]$
static_assert( std::is_base_of<policy_intrusive_base, $nss rest="::" after="::"$$class$>::value, "class '$class$' must be derived from coid::policy_intrusive_base");

$-[iface]$
////////////////////////////////////////////////////////////////////////////////
// interface $name$ of class $..class$
$[ns]$
namespace $@value$ {
$-[/ns]$

///
class $name$_dispatcher : public $name$
{
private:

    static coid::binstring* _capture;
    static uint16 _instid;
    static ifn_t* _vtable1;
    static ifn_t* _vtable2;

    static ifn_t* get_vtable()
    {
        if(_vtable1) return _vtable1;

        _vtable1 = new ifn_t[$nifcmethods$];
$-[method !static?]$
        _vtable1[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&$....ns$::$....class$::$intname$));
$-[/method]-$

        return _vtable1;
    }
    
    #define VT_CALL2(R,F,I) ((*reinterpret_cast<policy_intrusive_base*>(this)).*(reinterpret_cast<R(policy_intrusive_base::*)F>(_vtable1[I])))
    
$-[method capture?]$

    $return.type$ __capture__$(if operator?)$operator$(elif)$$name$$index$$(/if)$($[args rest=", "]$$type$ $name$$[/args]$)$(if const?)$ const$(/if)$
    {
        (*_capture) << uint16(_instid | $index$) $-[args inarg?]$ << $name$$[/args]$;
        return VT_CALL2($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
    }
$-[/method]$

    static ifn_t* get_vtable_intercept()
    {
        if(_vtable2) return _vtable2;
        ifn_t* vtable1 = get_vtable();

        _vtable2 = new ifn_t[$nifcmethods$];
$-[method !static?]$
    $-(if capture? operator?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__operator));
    $-(elif capture?)$
        _vtable2[$@order$] = reinterpret_cast<ifn_t>(static_cast<$return.type$(policy_intrusive_base::*)($[args rest=","]$$type$$[/args]$)$(if const?)$const$(/if)$>(&__capture__$name$$index$));
    $-(elif)$
        _vtable2[$@order$] = vtable1[$@order$];
    $-(/if)$
$-[/method]-$

        return _vtable2;
    }
    
protected:

    $name$_dispatcher()
    {}
    
    bool intergen_bind_capture( coid::binstring* capture, uint instid ) override
    {
        if(instid >= 0xffU)
            return false;
    
        _instid = uint16(instid << 8U);
        _capture = capture;
        _vtable = _capture ? get_vtable_intercept() : get_vtable();
        return true;
    }    

    void intergen_capture_dispatch( uint mid, coid::binstring& bin ) override
    {
        switch(mid) {
        $-[method capture?]$
        case $index$: {
            $-[args inarg?]$
            const $basetype$& $name$ = bin.fetch<$basetype$>();
            $-[/args]$
            VT_CALL($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$);
            break;
        }
        $-[/method]$
        case UMAX32:
        default: throw coid::exception("unknown method id in $name$ capture dispatcher");
        }
    }
$-(if varname?)$

    ///Cleanup routine called from ~$name$()
    static void _cleaner_callback( $name$* m, intergen_interface* ifc ) {
        policy_intrusive_base* host = static_cast<$name$_dispatcher*>(m)->_host.get();
        if(host) static_cast<$..ns default=" "$::$..class$*>(host)->$varname$ = ifc;
    }
$-(/if)$

public:

    // creator methods
    
$-[method static?]$
    static iref<$..name$> $name$( $..name$* __here__$[args]$, $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ )
    {
        iref<$....ns default=" "$::$....class$> host = $....ns$::$....class$::$intname$($[args rest=", "]$$name$$[/args]$);
        if(!host)
            return 0;

        $..name$_dispatcher* __disp__ = static_cast<$..name$_dispatcher*>(__here__);
        if(!__disp__)
            __disp__ = new $..name$_dispatcher;

        __disp__->_host.create(host.get());
        __disp__->_vtable = _capture ? get_vtable_intercept() : get_vtable();
        
        $--(if ..varname?)$
        if(!host->$..varname$) {
            __disp__->_cleaner = &_cleaner_callback;
            host->$..varname$ = __disp__;
        }
        $-(/if)$
        
        $-(if ..oncreateev?)$
        __disp__->$..oncreateev$();

        $-(/if)$
        $-(if ..oncreate?)$
        host->$..oncreate$();

        $-(/if)$
        return iref<$..name$>(__disp__);
    }

$-[/method]$
    ///Register interface creators in the global registry
    static void* register_interfaces()
    {
$-[method static?]$
        interface_register::register_interface_creator(
            "$..ns rest="::" after="::"$$..name$.$name$@$..hash$", (void*)&$name$);
$-[/method]$

        return (void*)&register_interfaces;
    }
};

coid::binstring* $name$_dispatcher::_capture = 0;
uint16 $name$_dispatcher::_instid = 0xffffU;
intergen_interface::ifn_t* $name$_dispatcher::_vtable2 = 0;
intergen_interface::ifn_t* $name$_dispatcher::_vtable1 = 0;


//auto-register the available interface creators
static void* $name$_autoregger = $name$_dispatcher::register_interfaces();

void* force_register_$name$() {
    return $name$_dispatcher::register_interfaces();
}

$-[ns]$
} //namespace
$-[/ns]$

$-(if event?)$
// events

$[..nss]$namespace $@value$ {
$[/..nss]-$

$-[event !implicit?]$
$return.type$ $....class$::$intname$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$)
{
	if(!$..varname$) throw coid::exception("interface client not connected");
    return static_cast<$..ns rest="::" after="::"$$..name$&>(*$..varname$).$name$($[args rest=", "]$$name$$[/args]$);
}
$[/event]-$

$[..nss]$} //namespace
$[/..nss]-$
$(/if)-$

$-[/iface]$$[/class]$

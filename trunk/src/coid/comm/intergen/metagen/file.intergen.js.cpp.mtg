
//@file $name$ javascript interface dispatcher generated by intergen

$-[class]$$[iface]$
#include "$relpathjs$"
$-[/iface]$$[/class]$

#include <comm/metastream/metastream.h>
#include <comm/metastream/fmtstream_v8.h>
#include <comm/binstream/filestream.h>
#include <comm/binstream/binstreambuf.h>

using namespace coid;


////////////////////////////////////////////////////////////////////////////////
static void throw_js_error( v8::TryCatch& tc, const char* str )
{
    v8::String::Utf8Value error(tc.Exception());

    v8::HandleScope handle_scope;
    v8::String::Utf8Value exc(tc.Exception());

    v8::Handle<v8::Message> message = tc.Message();
    if(message.IsEmpty()) {
        throw exception() << str << *exc;
    }
    else {
        v8::String::Utf8Value filename(message->GetScriptResourceName());
        const char* filename_string = *filename;
        int linenum = message->GetLineNumber();

        throw exception() << filename_string << '(' << linenum << "): " << *exc;
    }
}

static void _js_release_callback(v8::Persistent<v8::Value> object, void* p)
{
    if(p)
        static_cast<intergen_interface*>(p)->release_refcount();
    object.Dispose();
}
$-(if irefargs?)$

// forward declarations for used iref arguments
$-[irefargs]$
v8::Handle<v8::Object> js_$fulltype$_create_wrapper( $type$&, v8::Handle<v8::Context> );

$-[/irefargs]$
$-(/if)$

$-[class]$$[iface rest="\n\n"]$
////////////////////////////////////////////////////////////////////////////////
//
// javascript handler of interface $name$ of class $..class$
//
////////////////////////////////////////////////////////////////////////////////

$-[ns]$
namespace $@value$ {
$-[/ns]$
namespace js {

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty?)$$[comments]$
//$@value$
$-[/comments]$$(/if)$
class $name$_js_dispatcher
    : public $ns rest="::"$::$name$
{
    iref<$ns rest="::"$::$name$> _base;

    v8::Persistent<v8::Context> _context;
    v8::Persistent<v8::Script> _script;
    v8::Persistent<v8::Object> _object;
$-(if event?)$
    v8::Persistent<v8::Function> _events[$event.@size$];
    bool _bound_events;
$-(/if)$

    coid::metastream _meta;
    coid::fmtstream_v8 _fmtv8;
    
    //iref<policy_intrusive_base> _extref;
    
    $ns rest="::"$::$name$& _real() { return _base ? *_base : *this; }
    
$-(if hasprops?)$
    static v8::Handle<v8::Value> _getter(v8::Local<v8::String> property, const v8::AccessorInfo &info);
    static v8::Handle<v8::Value> _setter(v8::Local<v8::String> property, v8::Local<v8::Value> value, const v8::AccessorInfo &info);

$-(/if)$
public:

    v8::Handle<v8::Object> create_interface_object( bool make_weak );

    static v8::Handle<v8::Script> load_script( const coid::token& scriptfile, const coid::token& file_name );
$-(if event?)$
    void bind_events( v8::Handle<v8::Context> context, bool force );
$-(/if)$

    $name$_js_dispatcher() $(if event?)$: _bound_events(false) $(/if)$
    {
        //_context = context;
        _meta.bind_formatting_stream(_fmtv8);
    }

    $name$_js_dispatcher( v8::Handle<v8::Context> context, iref<$ns rest="::" after="::"$$name$>& orig ) $(if event?)$: _bound_events(false) $(/if)${
        _base = orig;
        _context = v8::Persistent<v8::Context>::New(context);
        _meta.bind_formatting_stream(_fmtv8);
/*
        $name$_js_dispatcher* disp = static_cast<$name$_js_dispatcher*>(orig.get());
        //_host.swap(disp->_host);
        //_vtable = disp->_vtable;
$-(if varname?)$
        _cleaner = disp->_cleaner;
        disp->_cleaner = 0;
        _cleaner(this, this);
$-(/if)$*/
    }

    ~$name$_js_dispatcher() {
$-[event]$
        _events[$@index$].Dispose();
$-[/event]$
        _object.Dispose();
        _script.Dispose();
        _context.Dispose();
    }

    // --- creators ---

$-[method static?]$
$(if !comments.empty?)$$[comments]-$
    //$@value$
$[/comments]$$(/if)-$
    static iref<$..name$_js_dispatcher> $name$( const script_handle& scriptpath
        $-[args]$, $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$, const coid::token& bindname, v8::Handle<v8::Context>* );

    $-(if !internal?)$
    static v8::Handle<v8::Value> v8creator_$name$$@order$(const v8::Arguments& args);

    $-(/if)$
$-[/method]$
    ///Handler for generic $$query_interface javascript method
    static v8::Handle<v8::Value> v8query_interface( const v8::Arguments& args );
    
    // --- method wrappers ---

$-[method !static? !destroy? !internal? !operator?]$
    static v8::Handle<v8::Value> v8_$name$$@index$(const v8::Arguments& args);
$-[/method]$
$-(if event.empty!)$

    // --- interface events ---

$-[event]$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) override;
$-[/event]$

$-[event]$
    virtual bool is_implemented_$name$() override { return !unbound_event($@index$); }
$-[/event]$

private:
    bool unbound_event( int id )
    {
        if(!_bound_events) {
            v8::Context::Scope context_scope(_context);
            v8::HandleScope __handle_scope;
            v8::TryCatch __trycatch;

            bind_events(_context, false);
        }

        return _events[id].IsEmpty() || _events[id]->IsUndefined();
    }
$-(/if)$
};

$-[method !static? !destroy? !internal? !operator?]$
////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Value> $..name$_js_dispatcher::v8_$name$$@index$(const v8::Arguments& args)
{
    if(args.Length() != $ninargs_nondef$)  //in/inout arguments
        return v8::ThrowException(v8::String::New("Wrong number of arguments"));

    v8::HandleScope _handle_scope_;
    v8::Local<v8::Object> _obj_ = args.Holder();

    $..ns rest="::" after="::"$js::$..name$_js_dispatcher* ifc = static_cast<$..ns rest="::" after="::"$js::$..name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(_obj_->GetInternalField(0))->Value());

    v8::Context::Scope context_scope(ifc->_context);

    //stream the arguments in
$-[args inarg? !nojs?]$
 $-(if iref.true?)$
  $-(if !defval.empty?)$
    $basetype$ $name$;
    if($@order$ < args.Length())
        $name$ = js_unwrap_object<typename $basetype$::base_t>(args[$@order$]);
    else
        $name$ = $defval$;
  $-(elif)$
    $basetype$ $name$ = js_unwrap_object<typename $basetype$::base_t>(args[$@order$]);
  $-(/if)$
 $-(elif enum?)$
  $-(if !defval.empty?)$
    $basetype$ $name$ = $@order$ < args.Length()
        ? static_cast<$basetype$>( v8_streamer<int>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$] )
        : $defval$;
  $-(elif)$
    $basetype$ $name$ = static_cast<$basetype$>( v8_streamer<int>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$] );
  $-(/if)$
 $-(elif)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
  $-(if !defval.empty?)$
    $basetype$ $name$ = $@order$ < args.Length()
        ? v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$]
        : $defval$;
  $-(elif)$
    $basetype$ $name$ = v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$];
  $-(/if)$
 $-(/if)$
$[/args]-$

    ifc->_meta.stream_acknowledge();

    //invoke
$-[args outarg? !inarg?]$
    $basetype$ $name$;
$[/args]-$

    $(if return.type!="void")$$return.type$ _rval_ = $(/if)$ifc->_real().$name$($[args rest=", "]$ $-(if nojs?)$$defval$$(elif)$$name$$base2arg$$(/if)$$[/args]$);

    //stream out
$-(if return.type!="void")$
 $-(if return.iref.false? noutargs?)$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator << for type '$return.type$'" );
    v8::Handle<v8::Object> _r_ = v8::Object::New();
    _r_->Set(v8::String::NewSymbol("$$ret"), v8_streamer<$return.type$>(&ifc->_fmtv8, &ifc->_meta) << _rval_);
 $-(elif noutargs?)$
    v8::Handle<v8::Object> _r_ = v8::Object::New();
    _r_->Set(v8::String::NewSymbol("$$ret"), js_$return.fulltype$_create_wrapper(_rval_, ifc->_context));
 $-(elif return.iref.false?)$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator << for type '$return.type$'" );
    v8::Handle<v8::Value> _r_ = v8_streamer<$return.type$>(&ifc->_fmtv8, &ifc->_meta) << _rval_;
 $-(elif)$
    v8::Handle<v8::Value> _r_ = js_$return.fulltype$_create_wrapper(_rval_, ifc->_context);
 $-(/if)$

 $-[args outarg?]$
  $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
    _r_->Set(v8::String::NewSymbol("$name$"), v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) << $name$);
  $-(elif)$
    _r_->Set(v8::String::NewSymbol("$name$"), js_$fulltype$_create_wrapper($name$, ifc->_context));
  $-(/if)$
 $[/args]-$
$-(elif noutargs?="1")$
 $-[args outarg?]$
  $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
    v8::Handle<v8::Value> _r_ = v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) << $name$;
  $-(elif)$
    v8::Handle<v8::Value> _r_ = js_$fulltype$_create_wrapper(_rval_, ifc->_context);
  $-(/if)$
 $[/args]-$
$-(elif noutargs?)$
    v8::Handle<v8::Object> _r_ = v8::Object::New();
 $-[args outarg?]$
  $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
    _r_->Set(v8::String::NewSymbol("$name$"), v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) << $name$);
  $-(elif)$
    _r_->Set(v8::String::NewSymbol("$name$"), js_$fulltype$_create_wrapper($name$, ifc->_context));
  $-(/if)$
 $[/args]-$
$-(elif)$
    v8::Handle<v8::Object> _r_;
$(/if)-$

    ifc->_meta.stream_flush();

    return _handle_scope_.Close(_r_);
}

$-[/method]$
$-[event]$
////////////////////////////////////////////////////////////////////////////////
$return.type$ $..name$_js_dispatcher::$name$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$)
{
    v8::Context::Scope context_scope(_context);
    v8::HandleScope __handle_scope;
    v8::TryCatch __trycatch;

    bind_events(_context, false);

$-(if return.type?="void" !noutargs?)$
    if(_events[$@index$].IsEmpty() || _events[$@index$]->IsUndefined())
        return;

$-(/if)$
$-[args inarg?]$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
$-[/args]$
$-(if args?)$
    v8::Handle<v8::Value> __inargs[] = {
$-[args inarg?]$
        v8_streamer<$basetype$>(&_fmtv8, &_meta) << $name$,
$-[/args]$
    };

$-(/if)$
    _meta.stream_flush();

    v8::Local<v8::Value> _r_ = _events[$@index$]->Call(_object, $(if args?)$sizeof(__inargs)/sizeof(v8::Handle<v8::Value>), __inargs$(elif)$0, 0$(/if)$);

    if(__trycatch.HasCaught())
        throw_js_error(__trycatch, "$..ns rest="::" after="::"$js::$..name$::$name$(): ");
$-(if !noutargs?)$

 $-(if return.type!="void")$
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator << for type '$return.type$'" );
    $return.type$ _rval_ = v8_streamer<$return.type$>(&_fmtv8, &_meta) >> _r_;
 $-(/if)$
$-(elif)$

    if(!_r_->IsObject()) throw coid::exception("invalid params");
    v8::Local<v8::Object> _obj_ = _r_->ToObject();
 $-(if return.type!="void")$
    //return value
    static_assert( CHECK::meta_operator_exists<$return.type$>::value, "missing metastream operator << for type '$return.type$'" );
    $return.type$ _rval_ = v8_streamer<$return.type$>(&_fmtv8, &_meta) >> _obj_->Get(v8::String::NewSymbol("$$ret"));
 $-(/if)$
 $-[args outarg?]$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
    $name$ = v8_streamer<$basetype$>(&_fmtv8, &_meta) >> _obj_->Get(v8::String::NewSymbol("$name$"));
 $-[/args]$
$(/if)-$

    _meta.stream_acknowledge();
$-(if return.type!="void")$

    return _rval_;
$-(/if)$
}

$-[/event]$
$-(if hasprops?)$
////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Value> $name$_js_dispatcher::_getter(v8::Local<v8::String> property, const v8::AccessorInfo &info)
{
    v8::HandleScope _handle_scope_;
    v8::Local<v8::Object> _obj_ = info.Holder();

    v8::Local<v8::Value> _intobj_ = _obj_->GetInternalField(0);
    if(!_intobj_->IsExternal())
        return v8::Handle<v8::Value>();

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(_intobj_)->Value());

    v8::Context::Scope context_scope(ifc->_context);

    v8::String::AsciiValue key(property);
$-(if getter.token?)$    
    $getter.basetype$ value = ifc->_real()(coid::token(*key, key.length()));
$-(elif)$
    $getter.basetype$ value = ifc->_real()(*key);
$-(/if)$
    
    //stream out
$-(if getter.iref.false?)$
    static_assert( CHECK::meta_operator_exists<$getter.basetype$>::value, "missing metastream operator << for type '$getter.basetype$'" );
    v8::Handle<v8::Value> _r_ = v8_streamer<$getter.basetype$>(&ifc->_fmtv8, &ifc->_meta) << value;
    ifc->_meta.stream_flush();
$-(elif)$
    v8::Handle<v8::Object> _r_ = js_$getter.fulltype$_create_wrapper(value, ifc->_context);
$-(/if)$

    return _handle_scope_.Close(_r_);
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Value> $name$_js_dispatcher::_setter(v8::Local<v8::String> property, v8::Local<v8::Value> value, const v8::AccessorInfo &info)
{
    v8::HandleScope _handle_scope_;
    v8::Local<v8::Object> _obj_ = info.Holder();

    v8::Local<v8::Value> _intobj_ = _obj_->GetInternalField(0);
    if(!_intobj_->IsExternal())
        return v8::Handle<v8::Value>();

    $ns rest="::" after="::"$js::$name$_js_dispatcher* ifc = static_cast<$ns rest="::" after="::"$js::$name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(_intobj_)->Value());

    v8::Context::Scope context_scope(ifc->_context);

    static_assert( CHECK::meta_operator_exists<$setter.basetype$>::value, "missing metastream operator << for type '$setter.basetype$'" );
    $setter.basetype$ val = v8_streamer<$setter.basetype$>(&ifc->_fmtv8, &ifc->_meta) >> value;
    ifc->_meta.stream_acknowledge();
    
    v8::String::AsciiValue key(property);
$-(if setter.token?)$
    ifc->_real()(coid::token(*key, key.length()), val);
$-(elif)$
    ifc->_real()(*key, val);
$-(/if)$

    return _handle_scope_.Close(value);
}

$-(/if)$
////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Value> $name$_js_dispatcher::v8query_interface(const v8::Arguments& args)
{
    if(args.Length() < 1)
        return v8::ThrowException(v8::String::New("interface creator name required"));

    v8::HandleScope _handle_scope_;
    v8::String::AsciiValue key(args[0]);
    
    typedef v8::Handle<v8::Value> (*fn_get)(const v8::Arguments& args);
    fn_get get = reinterpret_cast<fn_get>(
        coid::interface_register::get_interface_creator(coid::token(*key, key.length())));

    if(!get)
        return v8::ThrowException(v8::String::New("interface creator not found"));

    return _handle_scope_.Close(get(args));
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Object> $name$_js_dispatcher::create_interface_object( bool make_weak )
{
    static v8::Persistent<v8::ObjectTemplate> _objtempl;
    if(_objtempl.IsEmpty())
    {
        _objtempl = v8::Persistent<v8::ObjectTemplate>::New( v8::ObjectTemplate::New() );
        _objtempl->SetInternalFieldCount(2);    //ptr and class hash id

$-[method !static? !destroy? !internal? !operator?]$
        _objtempl->Set(v8::String::NewSymbol("$name$"), v8::FunctionTemplate::New(&v8_$name$$@index$));
$-[/method]$
        _objtempl->Set(v8::String::NewSymbol("$$query_interface"), v8::FunctionTemplate::New(&v8query_interface));
$-(if hasprops?)$

        _objtempl->SetNamedPropertyHandler(&_getter, &_setter);
$-(/if)$
    }

    v8::Local<v8::Object> obj = _objtempl->NewInstance();

    v8::Handle<v8::External> map_ptr = v8::External::New(this);
    obj->SetInternalField(0, map_ptr);
    v8::Handle<v8::External> hash_ptr = v8::External::New((void*)$hash$);
    obj->SetInternalField(1, hash_ptr);

    if(make_weak) {
        v8::Persistent<v8::Object>::New(obj).MakeWeak(this, _js_release_callback);
        add_refcount();
    }

    return obj;
}

////////////////////////////////////////////////////////////////////////////////
v8::Handle<v8::Script> $name$_js_dispatcher::load_script( const coid::token& script, const coid::token& fname )
{
    v8::Local<v8::String> scriptv8 = v8::String::New(script.ptr(), script.len());

    // set up an error handler to catch any exceptions the script might throw.
    v8::TryCatch __trycatch;

    v8::Handle<v8::Script> compiled_script = v8::Script::Compile(scriptv8, v8::String::New(fname.ptr(), fname.len()));
    if(__trycatch.HasCaught())
        throw_js_error(__trycatch, "$ns rest="::" after="::"$js::$name$::load_script(): ");

    compiled_script->Run();
    if(__trycatch.HasCaught())
        throw_js_error(__trycatch, "$ns rest="::" after="::"$js::$name$::load_script(): ");

    return compiled_script;
}

$-(if event?)$
////////////////////////////////////////////////////////////////////////////////
void $name$_js_dispatcher::bind_events( v8::Handle<v8::Context> context, bool force )
{
    if(!force && _bound_events)
        return;

    static token names[] = {
$-[event]$
        "$name$",
$-[/event]$
    };
    static bool mandatory[] = {
$-[event]$
        $(if return.type?="void" !noutargs?)$false$(elif)$true$(/if)$,
$-[/event]$
    };

    v8::TryCatch __trycatch;
    v8::Local<v8::Object> global = context->Global();

    for(int i=0; i<$event.@size$; ++i) {
        v8::Local<v8::Value> var = global->Get(v8::String::New(names[i].ptr(), names[i].len()));
        if(__trycatch.HasCaught()) {
            if(!mandatory[i]) continue;
            throw_js_error(__trycatch, "$ns rest="::" after="::"$js::$name$::bind_events(): ");
        }

        v8::Local<v8::Function> foo = v8::Local<v8::Function>::Cast(var);
        if(__trycatch.HasCaught() && mandatory[i])
            throw_js_error(__trycatch, "$ns rest="::" after="::"$js::$name$::bind_events(): ");

        _events[i] = v8::Persistent<v8::Function>::New(foo);
    }

    _bound_events = true;
}

$-(/if)$
$-[method static?]$
////////////////////////////////////////////////////////////////////////////////
iref<$..name$_js_dispatcher> $..name$_js_dispatcher::$name$( const script_handle& script
        $-[args]$, $type$ $name$$size$$[/args]$, const coid::token& bindname, v8::Handle<v8::Context>* ctx )
{
    //v8::Persistent<v8::Context> context_per;
    v8::HandleScope scope;
    v8::Handle<v8::Context> context;

    //iref<policy_intrusive_base> extref;

    // create interface object
    iref<$..name$_js_dispatcher> ifc = $..ns rest="::" after="::"$$..name$::$name$($[args rest=", " after=", "]$$name$$[/args]$new $..name$_js_dispatcher);

    // check if an external context provider is required
    if(script.is_path()) {
        coid::token path = script.str();
        path.cut_right('?', coid::token::cut_trait_remove_sep_default_empty());
        
        bool ispage = path.begins_with("http://") || path.begins_with("https://") || path.ends_with(".html");
        bool isscript = path.ends_with(".js");

        if(ispage && !isscript) {
            typedef v8::Handle<v8::Context> (*fn_getctx)(const coid::token&, policy_intrusive_base*);

            fn_getctx ctxgetter = reinterpret_cast<fn_getctx>(
                    coid::interface_register::get_interface_creator("~html@system_context_getter2"));

            if(!ctxgetter)
                throw coid::exception() << "unable to acquire the system context creator interface";

            context = ctxgetter(script.str(), ifc.get());
        }
    }

    bool extctx = !context.IsEmpty();
    
    if(!extctx) {
        if(script.is_context())
            context = script.context();
        else
            context = v8::Context::New();
    }
    
    v8::Context::Scope context_scope(context);
    ifc->_context = v8::Persistent<v8::Context>::New(context);

    //if(!script.is_context())
    //    context->Global()->Set(v8::String::NewSymbol("$$query_interface"), v8::FunctionTemplate::New(&v8query_interface)->GetFunction());

    if(extctx || script.is_context()) {
        //ifc = $..ns rest="::" after="::"$$..name$::$name$($[args rest=", " after=", "]$$name$$[/args]$new $..name$_js_dispatcher(context));
        
        ifc->_object = v8::Persistent<v8::Object>::New(ifc->create_interface_object(false));
    }
    else {
        //ifc = $..ns rest="::" after="::"$$..name$::$name$($[args rest=", " after=", "]$$name$$[/args]$new $..name$_js_dispatcher(context_per));

        coid::token script_tok, script_path;
        coid::charstr script_tmp;
        if(script.is_path()) {
            script_path = script.str();
            coid::bifstream bif(script_path);
            if(!bif.is_open())
                throw coid::exception() << script_path << " not found";
                
            script_tmp = script.prefix();

            coid::binstreambuf buf;
            buf.swap(script_tmp);
            buf.transfer_from(bif);
            buf.swap(script_tmp);
            
            script_tok = script_tmp;
        }
        else if(script.prefix()) {
            script_tmp << script.prefix() << script.str();
            script_tok = script_tmp;
            script_path = "$..name$";
        }
        else {
            script_tok = script.str();
            script_path = "$..name$";
        }

        v8::Handle<v8::Script> compiled_script = load_script(script_tok, script_path);

        ifc->_script = v8::Persistent<v8::Script>::New(compiled_script);
        ifc->_object = v8::Persistent<v8::Object>::New(ifc->create_interface_object(false));
    }

    //if(extref)
    //    extref.swap(ifc->_extref);

    if(bindname)
        context->Global()->Set(v8::String::New(bindname.ptr(), bindname.len()), ifc->_object);

    if(ctx) *ctx = context;

    return ifc;
}

$-(if !internal?)$
////////////////////////////////////////////////////////////////////////////////
///Creator methods for access from JS
v8::Handle<v8::Value> $..name$_js_dispatcher::v8creator_$name$$@order$(const v8::Arguments& args)
{
    if(args.Length() != 1+$ninargs$)  //fnc name + in/inout arguments
        return v8::ThrowException(v8::String::New("Wrong number of arguments"));

    v8::HandleScope _handle_scope_;
    v8::Local<v8::Object> _obj_ = args.Holder();

    $..ns rest="::" after="::"$js::$..name$_js_dispatcher* ifc = static_cast<$..ns rest="::" after="::"$js::$..name$_js_dispatcher*>
        (v8::Handle<v8::External>::Cast(_obj_->GetInternalField(0))->Value());

    v8::Context::Scope context_scope(ifc->_context);

    //stream the arguments in
$-[args inarg? !nojs?]$
 $-(if iref.true?)$
  $-(if !defval.empty?)$
    $basetype$ $name$;
    if($@order$ < args.Length())
        $name$ = js_unwrap_object<typename $basetype$::base_t>(args[$@order$]);
    else
        $name$ = $defval$;
  $-(elif)$
    $basetype$ $name$ = js_unwrap_object<typename $basetype$::base_t>(args[$@order$]);
  $-(/if)$
 $-(elif enum?)$
  $-(if !defval.empty?)$
    $basetype$ $name$ = $@order$ < args.Length()
        ? static_cast<$basetype$>( v8_streamer<int>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$] )
        : $defval$;
  $-(elif)$
    $basetype$ $name$ = static_cast<$basetype$>( v8_streamer<int>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$] );
  $-(/if)$
 $-(elif)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
  $-(if !defval.empty?)$
    $basetype$ $name$ = $@order$ < args.Length()
        ? v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$]
        : $defval$;
  $-(elif)$
    $basetype$ $name$ = v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) >> args[$@order$];
  $-(/if)$
 $-(/if)$
$[/args]-$

    ifc->_meta.stream_acknowledge();

    //invoke
$-[args outarg? !inarg?]$
    $basetype$ $name$;
$[/args]-$

    iref<$..name$_js_dispatcher> nifc = $..ns rest="::" after="::"$$..name$::$name$($[args rest=", " after=", "]$$name$$[/args]$new $..name$_js_dispatcher);
    nifc->_context = v8::Persistent<v8::Context>::New(ifc->_context);

    //stream out
$-(if return.type!="void")$
 $-(if noutargs?)$
    v8::Handle<v8::Object> _r_ = v8::Object::New();
    _r_->Set(v8::String::NewSymbol("$$ret"), nifc->create_interface_object(true));
 $-(elif)$
    v8::Handle<v8::Value> _r_ = nifc->create_interface_object(true);
 $-(/if)$
$(/if)-$
$-[args outarg?]$
 $-(if iref.false?)$
    static_assert( CHECK::meta_operator_exists<$basetype$>::value, "missing metastream operator << for type '$basetype$'" );
    _r_->Set(v8::String::NewSymbol("$name$"), v8_streamer<$basetype$>(&ifc->_fmtv8, &ifc->_meta) << $name$);
 $-(elif)$
    _r_->Set(v8::String::NewSymbol("$name$"), js_$fulltype$_create_wrapper($name$, ifc->_context));
 $-(/if)$
$[/args]-$

    ifc->_meta.stream_flush();

    return _handle_scope_.Close(_r_);
}

$-(/if)$
$-[/method]$
////////////////////////////////////////////////////////////////////////////////
void* register_binders_for_$name$()
{
$-[method static?]$
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$js::$..name$::$name$@creator", (void*)&$..name$_js_dispatcher::$name$);
$-(if !internal?)$
    interface_register::register_interface_creator(
        "$..ns rest="::" after="::"$js::$..name$::$name$", (void*)&$..name$_js_dispatcher::v8creator_$name$$@order$);
$-(/if)$
$-[/method]$

    return (void*)&register_binders_for_$name$;
}

//auto-register the bind function
static void* autoregger_$name$ = register_binders_for_$name$();

} //namespace js
$-[ns]$
} //namespace
$-[/ns]$

////////////////////////////////////////////////////////////////////////////////
///Create JS wrapper from existing interface object
v8::Handle<v8::Object> js_$ns rest="_" after="_"-$ $name$_create_wrapper( iref<$ns rest="::" after="::"$$name$>& orig, v8::Handle<v8::Context> context )
{
    // check that the orig points to an object
    if(!orig) return v8::Handle<v8::Object>();

    // create interface object
    iref<$ns rest="::" after="::"$js::$name$_js_dispatcher> ifc;
    ifc.create(new $ns rest="::" after="::"$js::$name$_js_dispatcher(context, orig));

    v8::Context::Scope context_scope(context);
    v8::HandleScope scope;

    v8::Handle<v8::Object> obj = ifc->create_interface_object(true);

    return scope.Close(obj);
}

$-[/iface]$$[/class]$

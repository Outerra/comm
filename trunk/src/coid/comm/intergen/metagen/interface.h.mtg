
#ifndef __INTERGEN_GENERATED__$name$_H__
#define __INTERGEN_GENERATED__$name$_H__

//@file Interface file for $name$ interface generated by the intergen tool

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

$-(if base?)$#include "$baseclass$.h"$(/if)$

$-[pasters]-$
$@value$
$-[/pasters]-$

$-[ns]$
namespace $@value$ {
$-[/ns]$

////////////////////////////////////////////////////////////////////////////////
$-(if !comments.empty?)$$[comments]$
//$@value$
$-[/comments]$$(/if)$
class $name$
    : public $(if base?)$$base$$(elif)$intergen_interface$(/if)$
{
protected:
$-(if varname?)$
    typedef void (*cleanup_fn)($name$*, intergen_interface*);
    cleanup_fn _cleaner;
$-(/if)$

    $name$()$(if varname?)$ : _cleaner(0)$(/if)$
    {}
    
$-(if destroy.name.empty!)$
    ~$name$() {
        VT_CALL($destroy.return.type$,($[destroy.args rest=","]$$type$$[/destroy.args]$),0)($[destroy.args rest=","]$$name$$[/destroy.args]$);
$-(if varname?)$
        if(_cleaner) _cleaner(this,0);
$-(/if)$
    }
$(/if)-$

public:
$-(if varname? destroy.name.empty?)$

    virtual ~$name$() {
        if(_cleaner) _cleaner(this,0);
    }
$-(/if)$

    ///class id
    static const int hashid = $hash$;

    // --- creators ---

$-[method static?]$
$(if !comments.empty?)$$[comments]-$
    //$@value$
$[/comments]$$(/if)-$
    static iref<$..name$> $name$(
        $-[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) {
        return $name$<$..name$>($[args rest=", " after=", "]$$name$$[/args]$0);
    }

    template<class T>
    static iref<T> $name$(
        $-[args rest="," after=","]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ T* here );
$-[/method]$

    // --- interface methods ---

$-[method !static? !destroy?]$
$(if !comments.empty?)$$[comments]-$
    //$@value$
$[/comments]$$(/if)-$
    $(if ..virtual?)$virtual $(/if)$$return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$) $-(if const?)$ const$(/if)$;
$[/method]-$

    // --- interface events ---

$-[event !static?]$
$(if !comments.empty?)$$[comments]-$
    //$@value$
$[/comments]$$(/if)-$
    virtual $return.type$ $name$($[args rest="," after=" "]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$)
    $-(if return.type?="void")$ {}$(elif)$ {throw coid::exception("handler not implemented");}$(/if)$
$-[/event]$

$-[event !static?]$
    virtual bool is_implemented_$name$() { return true; }
$-[/event]$
};


$-[method static?]$
////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> $..name$::$name$(
    $-[args rest="," after=","]$ $type$ $name$$size$ $-(if defval?)$ = $defval$$(/if)$$[/args]$ T* here )
{
    typedef iref<T> (*fn_creator)($[args rest=", " after=", "]$ $-type$$[/args]$ $-..name$*);

    static fn_creator create = 0;

    if(!create) {
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator("$..ns rest="::" after="::"$$..name$::$name$@$..hash$"));
    }

    if(!create)
        throw coid::exception("interface creator inaccessible");

    return create($[args rest=", " after=", "]$$name$$[/args]$here);
}
$-[/method]$


$-[method !static? !destroy?]$
inline $return.type$ $..name$::$name$($[args rest="," after=" "]$ $type$ $name$$size$$[/args]$) $-(if const?)$ const$(/if)$
{ return VT_CALL($return.type$,($[args rest=","]$$type$$[/args]$),$index$)($[args rest=","]$$name$$[/args]$); }
$[/method]-$

$-[ns]$
} //namespace
$-[/ns]$

#endif //__INTERGEN_GENERATED__$name$_H__
